{
    "name": "redshift",
    "keywords": [
        "AES128",
        "AES256",
        "ALL",
        "ALLOWOVERWRITE",
        "ANALYSE",
        "ANALYZE",
        "AND",
        "ANY",
        "ARRAY",
        "AS",
        "ASC",
        "AUTHORIZATION",
        "AZ64",
        "BACKUP",
        "BETWEEN",
        "BINARY",
        "BLANKSASNULL",
        "BOTH",
        "BYTEDICT",
        "BZIP2",
        "CASE",
        "CAST",
        "CHECK",
        "COLLATE",
        "COLUMN",
        "CONSTRAINT",
        "CREATE",
        "CREDENTIALS",
        "CROSS",
        "CURRENT_DATE",
        "CURRENT_TIME",
        "CURRENT_TIMESTAMP",
        "CURRENT_USER",
        "CURRENT_USER_ID",
        "DEFAULT",
        "DEFERRABLE",
        "DEFLATE",
        "DEFRAG",
        "DELTA",
        "DELTA32K",
        "DESC",
        "DISABLE",
        "DISTINCT",
        "DO",
        "ELSE",
        "EMPTYASNULL",
        "ENABLE",
        "ENCODE",
        "ENCRYPT     ",
        "ENCRYPTION",
        "END",
        "EXCEPT",
        "EXPLICIT",
        "FALSE",
        "FOR",
        "FOREIGN",
        "FREEZE",
        "FROM",
        "FULL",
        "GLOBALDICT256",
        "GLOBALDICT64K",
        "GRANT",
        "GROUP",
        "GZIP",
        "HAVING",
        "IDENTITY",
        "IGNORE",
        "ILIKE",
        "IN",
        "INITIALLY",
        "INNER",
        "INTERSECT",
        "INTERVAL",
        "INTO",
        "IS",
        "ISNULL",
        "JOIN",
        "LEADING",
        "LEFT",
        "LIKE",
        "LIMIT",
        "LOCALTIME",
        "LOCALTIMESTAMP",
        "LUN",
        "LUNS",
        "LZO",
        "LZOP",
        "MINUS",
        "MOSTLY16",
        "MOSTLY32",
        "MOSTLY8",
        "NATURAL",
        "NEW",
        "NOT",
        "NOTNULL",
        "NULL",
        "NULLS",
        "OFF",
        "OFFLINE",
        "OFFSET",
        "OID",
        "OLD",
        "ON",
        "ONLY",
        "OPEN",
        "OR",
        "ORDER",
        "OUTER",
        "OVERLAPS",
        "PARALLEL",
        "PARTITION",
        "PERCENT",
        "PERMISSIONS",
        "PIVOT",
        "PLACING",
        "PRIMARY",
        "RAW",
        "READRATIO",
        "RECOVER",
        "REFERENCES",
        "REJECTLOG",
        "RESORT",
        "RESPECT",
        "RESTORE",
        "RIGHT",
        "SELECT",
        "SESSION_USER",
        "SIMILAR",
        "SNAPSHOT ",
        "SOME",
        "SYSDATE",
        "SYSTEM",
        "TABLE",
        "TAG",
        "TDES",
        "TEXT255",
        "TEXT32K",
        "THEN",
        "TIMESTAMP",
        "TO",
        "TOP",
        "TRAILING",
        "TRUE",
        "TRUNCATECOLUMNS",
        "UNION",
        "UNIQUE",
        "UNNEST",
        "UNPIVOT",
        "USER",
        "USING",
        "VERBOSE",
        "WALLET",
        "WHEN",
        "WHERE",
        "WITH",
        "WITHOUT"
    ],
    "functions": [
        {
            "name": "ANY_VALUE",
            "description": "The ANY_VALUE function returns any value from the input expression values nondeterministically. This function returnsNULLif the input expression doesn't result in any rows being returned. The function can also returnNULLif there areNULLvalues in the input expression.",
            "syntax": "ANY_VALUE( [ DISTINCT | ALL ]expression)",
            "arguments": [
                {
                    "name": "DISTINCT | ALL",
                    "description": "Specify either DISTINCT or ALL to return any value from the input expression values. The DISTINCT argument has no effect and is ignored.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "expression",
                    "description": "The target column or expression on which the function operates. The expression is one of the following data types: SMALLINT INTEGER BIGINT DECIMAL REAL DOUBLE PRECISON BOOLEAN CHAR VARCHAR DATE TIMESTAMP TIMESTAMPTZ TIME TIMETZ INTERVAL YEAR TO MONTH INTERVAL DAY TO SECOND VARBYTE SUPER HLLSKETCH GEOMETRY GEOGRAPHY",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "APPROXIMATE  PERCENTILE_DISC",
            "description": "APPROXIMATE PERCENTILE_DISC is an inverse distribution function that assumes a discrete distribution model. It takes a percentile value and a sort specification and returns an element from the given set. Approximation enables the function to run much faster, with a low relative error of around 0.5 percent. For a givenpercentilevalue, APPROXIMATE PERCENTILE_DISC uses a quantile summary algorithm to approximate the discrete percentile of the expression in the ORDER BY clause. APPROXIMATE PERCENTILE_DISC returns the value with the smallest cumulative distribution value (with respect to the same sort specification) that is greater than or equal topercentile. APPROXIMATE PERCENTILE_DISC is a compute-node only function. The function returns an error if the query doesn't reference a user-defined table or Amazon Redshift system table.",
            "syntax": "APPROXIMATE  PERCENTILE_DISC(percentile)",
            "arguments": [
                {
                    "name": "percentile",
                    "description": "Numeric constant between 0 and 1. Nulls are ignored in the calculation.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "WITHIN GROUP ( ORDER BYexpr)",
                    "description": "Clause that specifies numeric or date/time values to sort and compute the percentile over.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "WITHIN GROUP",
            "description": "APPROXIMATE PERCENTILE_DISC is an inverse distribution function that assumes a discrete distribution model. It takes a percentile value and a sort specification and returns an element from the given set. Approximation enables the function to run much faster, with a low relative error of around 0.5 percent. For a givenpercentilevalue, APPROXIMATE PERCENTILE_DISC uses a quantile summary algorithm to approximate the discrete percentile of the expression in the ORDER BY clause. APPROXIMATE PERCENTILE_DISC returns the value with the smallest cumulative distribution value (with respect to the same sort specification) that is greater than or equal topercentile. APPROXIMATE PERCENTILE_DISC is a compute-node only function. The function returns an error if the query doesn't reference a user-defined table or Amazon Redshift system table.",
            "syntax": "WITHIN GROUP(ORDER BYexpr)",
            "arguments": [
                {
                    "name": "percentile",
                    "description": "Numeric constant between 0 and 1. Nulls are ignored in the calculation.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "WITHIN GROUP ( ORDER BYexpr)",
                    "description": "Clause that specifies numeric or date/time values to sort and compute the percentile over.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "AVG",
            "description": "The AVG function returns the average (arithmetic mean) of the input expression values. The AVG function works with numeric values and ignores NULL values.",
            "syntax": "AVG( [ DISTINCT | ALL ]expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The target column or expression that the function operates on. The expression is one of the following data types: SMALLINT INTEGER BIGINT NUMERIC DECIMAL REAL DOUBLE PRECISON SUPER",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "DISTINCT | ALL",
                    "description": "With the argument DISTINCT, the function eliminates all duplicate values from the specified expression before calculating the average. With the argument ALL, the function retains all duplicate values from the expression for calculating the average. ALL is the default.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "COUNT",
            "description": "The COUNT function counts the rows defined by the expression. The COUNT function has the following variations. COUNT ( * ) counts all the rows in the target table whether they include nulls or not. COUNT (expression) computes the number of rows with non-NULL values in a specific column or expression. COUNT ( DISTINCTexpression) computes the number of distinct non-NULL values in a column or expression. APPROXIMATE COUNT DISTINCT approximates the number of distinct non-NULL values in a column or expression.",
            "syntax": "COUNT( * |expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The target column or expression that the function operates on. The COUNT function supports all argument data types.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "DISTINCT | ALL",
                    "description": "With the argument DISTINCT, the function eliminates all duplicate values from the specified expression before doing the count. With the argument ALL, the function retains all duplicate values from the expression for counting. ALL is the default.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "APPROXIMATE",
                    "description": "When used with APPROXIMATE, a COUNT DISTINCT function uses a HyperLogLog algorithm to approximate the number of distinct non-NULL values in a column or expression. Queries that use the APPROXIMATE keyword run much faster, with a low relative error of around 2%. Approximation is warranted for queries that return a large number of distinct values, in the millions or more per query, or per group, if there is a group by clause. For smaller sets of distinct values, in the thousands, approximation might be slower than a precise count. APPROXIMATE can only be used with COUNT DISTINCT.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "COUNT",
            "description": "The COUNT function counts the rows defined by the expression. The COUNT function has the following variations. COUNT ( * ) counts all the rows in the target table whether they include nulls or not. COUNT (expression) computes the number of rows with non-NULL values in a specific column or expression. COUNT ( DISTINCTexpression) computes the number of distinct non-NULL values in a column or expression. APPROXIMATE COUNT DISTINCT approximates the number of distinct non-NULL values in a column or expression.",
            "syntax": "COUNT( [ DISTINCT | ALL ]expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The target column or expression that the function operates on. The COUNT function supports all argument data types.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "DISTINCT | ALL",
                    "description": "With the argument DISTINCT, the function eliminates all duplicate values from the specified expression before doing the count. With the argument ALL, the function retains all duplicate values from the expression for counting. ALL is the default.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "APPROXIMATE",
                    "description": "When used with APPROXIMATE, a COUNT DISTINCT function uses a HyperLogLog algorithm to approximate the number of distinct non-NULL values in a column or expression. Queries that use the APPROXIMATE keyword run much faster, with a low relative error of around 2%. Approximation is warranted for queries that return a large number of distinct values, in the millions or more per query, or per group, if there is a group by clause. For smaller sets of distinct values, in the thousands, approximation might be slower than a precise count. APPROXIMATE can only be used with COUNT DISTINCT.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "APPROXIMATE COUNT",
            "description": "The COUNT function counts the rows defined by the expression. The COUNT function has the following variations. COUNT ( * ) counts all the rows in the target table whether they include nulls or not. COUNT (expression) computes the number of rows with non-NULL values in a specific column or expression. COUNT ( DISTINCTexpression) computes the number of distinct non-NULL values in a column or expression. APPROXIMATE COUNT DISTINCT approximates the number of distinct non-NULL values in a column or expression.",
            "syntax": "APPROXIMATE COUNT( DISTINCTexpression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The target column or expression that the function operates on. The COUNT function supports all argument data types.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "DISTINCT | ALL",
                    "description": "With the argument DISTINCT, the function eliminates all duplicate values from the specified expression before doing the count. With the argument ALL, the function retains all duplicate values from the expression for counting. ALL is the default.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "APPROXIMATE",
                    "description": "When used with APPROXIMATE, a COUNT DISTINCT function uses a HyperLogLog algorithm to approximate the number of distinct non-NULL values in a column or expression. Queries that use the APPROXIMATE keyword run much faster, with a low relative error of around 2%. Approximation is warranted for queries that return a large number of distinct values, in the millions or more per query, or per group, if there is a group by clause. For smaller sets of distinct values, in the thousands, approximation might be slower than a precise count. APPROXIMATE can only be used with COUNT DISTINCT.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "LISTAGG",
            "description": "For each group in a query, the LISTAGG aggregate function orders the rows for that group according to the ORDER BY expression, then concatenates the values into a single string. LISTAGG is a compute node-only function. The function returns an error if the query doesn't reference a user-defined table or Amazon Redshift system table. For more information, seeQuerying the catalog tables.",
            "syntax": "LISTAGG( [DISTINCT]aggregate_expression[, 'delimiter' ] ) ",
            "arguments": [
                {
                    "name": "DISTINCT",
                    "description": "A clause that eliminates duplicate values from the specified expression before concatenating. Trailing spaces are ignored. For example, the strings 'a' and 'a ' are treated as duplicates. LISTAGG uses the first value encountered. For more information, see Significance of trailing blanks .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "aggregate_expression",
                    "description": "Any valid expression, such as a column name, that provides the values to aggregate. NULL values and empty strings are ignored.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "delimiter",
                    "description": "The string constant to separate the concatenated values. The default is NULL.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "WITHIN GROUP (ORDER BY order_list)",
                    "description": "A clause that specifies the sort order of the aggregated values.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "[ WITHIN GROUP",
            "description": "For each group in a query, the LISTAGG aggregate function orders the rows for that group according to the ORDER BY expression, then concatenates the values into a single string. LISTAGG is a compute node-only function. The function returns an error if the query doesn't reference a user-defined table or Amazon Redshift system table. For more information, seeQuerying the catalog tables.",
            "syntax": "[ WITHIN GROUP(ORDER BYorder_list) ]",
            "arguments": [
                {
                    "name": "DISTINCT",
                    "description": "A clause that eliminates duplicate values from the specified expression before concatenating. Trailing spaces are ignored. For example, the strings 'a' and 'a ' are treated as duplicates. LISTAGG uses the first value encountered. For more information, see Significance of trailing blanks .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "aggregate_expression",
                    "description": "Any valid expression, such as a column name, that provides the values to aggregate. NULL values and empty strings are ignored.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "delimiter",
                    "description": "The string constant to separate the concatenated values. The default is NULL.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "WITHIN GROUP (ORDER BY order_list)",
                    "description": "A clause that specifies the sort order of the aggregated values.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "MAX",
            "description": "The MAX function returns the maximum value in a set of rows. DISTINCT or ALL might be used but do not affect the result.",
            "syntax": "MAX( [ DISTINCT | ALL ]expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The target column or expression that the function operates on. The expression is one of the following data types: SMALLINT INTEGER BIGINT DECIMAL REAL DOUBLE PRECISON CHAR VARCHAR DATE TIMESTAMP TIMESTAMPTZ TIME TIMETZ VARBYTE SUPER",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "DISTINCT | ALL",
                    "description": "With the argument DISTINCT, the function eliminates all duplicate values from the specified expression before calculating the maximum. With the argument ALL, the function retains all duplicate values from the expression for calculating the maximum. ALL is the default.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "MEDIAN",
            "description": "Calculates the median value for the range of values.NULLvalues in the range are ignored. MEDIAN is an inverse distribution function that assumes a continuous distribution model. MEDIAN is a special case ofPERCENTILE_CONT. MEDIAN is a compute-node only function. The function returns an error if the query doesn't reference a user-defined table or Amazon Redshift system table.",
            "syntax": "MEDIAN(median_expression)",
            "arguments": [
                {
                    "name": "median_expression",
                    "description": "The target column or expression that the function operates on.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "MIN",
            "description": "The MIN function returns the minimum value in a set of rows. DISTINCT or ALL might be used but do not affect the result.",
            "syntax": "MIN( [ DISTINCT | ALL ]expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The target column or expression that the function operates on. The expression is one of the following data types: SMALLINT INTEGER BIGINT DECIMAL REAL DOUBLE PRECISON CHAR VARCHAR DATE TIMESTAMP TIMESTAMPTZ TIME TIMETZ VARBYTE SUPER",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "DISTINCT | ALL",
                    "description": "With the argument DISTINCT, the function eliminates all duplicate values from the specified expression before calculating the minimum. With the argument ALL, the function retains all duplicate values from the expression for calculating the minimum. ALL is the default.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "PERCENTILE_CONT",
            "description": "PERCENTILE_CONT is an inverse distribution function that assumes a continuous distribution model. It takes a percentile value and a sort specification, and returns an interpolated value that would fall into the given percentile value with respect to the sort specification. PERCENTILE_CONT computes a linear interpolation between values after ordering them. Using the percentile value(P)and the number of not null rows(N)in the aggregation group, the function computes the row number after ordering the rows according to the sort specification. This row number(RN)is computed according to the formulaRN = (1+ (P*(N-1)). The final result of the aggregate function is computed by linear interpolation between the values from rows at row numbersCRN = CEILING(RN)andFRN = FLOOR(RN). The final result will be as follows. If(CRN = FRN = RN)then the result is(value of expression from row at RN) Otherwise the result is as follows: (CRN - RN) * (value of expression for row at FRN) + (RN - FRN) * (value of expression for row at CRN). PERCENTILE_CONT is a compute-node only function. The function returns an error if the query doesn't reference a user-defined table or Amazon Redshift system table.",
            "syntax": "PERCENTILE_CONT(percentile)",
            "arguments": [
                {
                    "name": "percentile",
                    "description": "Numeric constant between 0 and 1. NULL values are ignored in the calculation.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "expr",
                    "description": "Specifies numeric or date/time values to sort and compute the percentile over.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "WITHIN GROUP",
            "description": "PERCENTILE_CONT is an inverse distribution function that assumes a continuous distribution model. It takes a percentile value and a sort specification, and returns an interpolated value that would fall into the given percentile value with respect to the sort specification. PERCENTILE_CONT computes a linear interpolation between values after ordering them. Using the percentile value(P)and the number of not null rows(N)in the aggregation group, the function computes the row number after ordering the rows according to the sort specification. This row number(RN)is computed according to the formulaRN = (1+ (P*(N-1)). The final result of the aggregate function is computed by linear interpolation between the values from rows at row numbersCRN = CEILING(RN)andFRN = FLOOR(RN). The final result will be as follows. If(CRN = FRN = RN)then the result is(value of expression from row at RN) Otherwise the result is as follows: (CRN - RN) * (value of expression for row at FRN) + (RN - FRN) * (value of expression for row at CRN). PERCENTILE_CONT is a compute-node only function. The function returns an error if the query doesn't reference a user-defined table or Amazon Redshift system table.",
            "syntax": "WITHIN GROUP(ORDER BYexpr)",
            "arguments": [
                {
                    "name": "percentile",
                    "description": "Numeric constant between 0 and 1. NULL values are ignored in the calculation.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "expr",
                    "description": "Specifies numeric or date/time values to sort and compute the percentile over.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "STDDEV_SAMP",
            "description": "The STDDEV_SAMP and STDDEV_POP functions return the sample and population standard deviation of a set of numeric values (integer, decimal, or floating-point). The result of the STDDEV_SAMP function is equivalent to the square root of the sample variance of the same set of values. STDDEV_SAMP and STDDEV are synonyms for the same function.",
            "syntax": "STDDEV_SAMP( [ DISTINCT | ALL ]expression)",
            "arguments": null
        },
        {
            "name": "STDDEV",
            "description": "The STDDEV_SAMP and STDDEV_POP functions return the sample and population standard deviation of a set of numeric values (integer, decimal, or floating-point). The result of the STDDEV_SAMP function is equivalent to the square root of the sample variance of the same set of values. STDDEV_SAMP and STDDEV are synonyms for the same function.",
            "syntax": "STDDEV( [ DISTINCT | ALL ]expression)",
            "arguments": null
        },
        {
            "name": "STDDEV_POP",
            "description": "The STDDEV_SAMP and STDDEV_POP functions return the sample and population standard deviation of a set of numeric values (integer, decimal, or floating-point). The result of the STDDEV_SAMP function is equivalent to the square root of the sample variance of the same set of values. STDDEV_SAMP and STDDEV are synonyms for the same function.",
            "syntax": "STDDEV_POP( [ DISTINCT | ALL ]expression)",
            "arguments": null
        },
        {
            "name": "SUM",
            "description": "The SUM function returns the sum of the input column or expression values. The SUM function works with numeric values and ignores NULL values.",
            "syntax": "SUM( [ DISTINCT | ALL ]expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The target column or expression that the function operates on. The expression is one of the following data types: SMALLINT INTEGER BIGINT NUMERIC DECIMAL REAL DOUBLE PRECISON SUPER",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "DISTINCT | ALL",
                    "description": "With the argument DISTINCT, the function eliminates all duplicate values from the specified expression before calculating the sum. With the argument ALL, the function retains all duplicate values from the expression for calculating the sum. ALL is the default.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "VAR_SAMP",
            "description": "The VAR_SAMP and VAR_POP functions return the sample and population variance of a set of numeric values (integer, decimal, or floating-point). The result of the VAR_SAMP function is equivalent to the squared sample standard deviation of the same set of values. VAR_SAMP and VARIANCE are synonyms for the same function.",
            "syntax": "VAR_SAMP( [ DISTINCT | ALL ]expression)",
            "arguments": null
        },
        {
            "name": "VARIANCE",
            "description": "The VAR_SAMP and VAR_POP functions return the sample and population variance of a set of numeric values (integer, decimal, or floating-point). The result of the VAR_SAMP function is equivalent to the squared sample standard deviation of the same set of values. VAR_SAMP and VARIANCE are synonyms for the same function.",
            "syntax": "VARIANCE( [ DISTINCT | ALL ]expression)",
            "arguments": null
        },
        {
            "name": "VAR_POP",
            "description": "The VAR_SAMP and VAR_POP functions return the sample and population variance of a set of numeric values (integer, decimal, or floating-point). The result of the VAR_SAMP function is equivalent to the squared sample standard deviation of the same set of values. VAR_SAMP and VARIANCE are synonyms for the same function.",
            "syntax": "VAR_POP( [ DISTINCT | ALL ]expression)",
            "arguments": null
        },
        {
            "name": "ARRAY",
            "description": "Creates an array of the SUPER data type.",
            "syntax": "ARRAY([ expr1 ][ , expr2 [ , ... ]] )",
            "arguments": [
                {
                    "name": "expr1, expr2",
                    "description": "Expressions of any Amazon Redshift data type except date and time types, since Amazon Redshift doesn't cast the date and time types to the SUPER data type. The arguments don't need to be of the same data type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "array_concat",
            "description": "The array_concat function concatenates two arrays to create an array that contains all the elements in the first array followed by all the elements in the second array. The two arguments must be valid arrays.",
            "syntax": "array_concat(super_expr1,super_expr2)",
            "arguments": [
                {
                    "name": "super_expr1",
                    "description": "The value that specifies the first of the two arrays to concatenate.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "super_expr2",
                    "description": "The value that specifies the second of the two arrays to concatenate.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "array_flatten",
            "description": "Merges multiple arrays into a single array of SUPER type.",
            "syntax": "array_flatten(super_expr1,super_expr2,.. )",
            "arguments": [
                {
                    "name": "super_expr1,super_expr2",
                    "description": "A valid SUPER expression of array form.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "get_array_length",
            "description": "Returns the length of the specified array. The GET_ARRAY_LENGTH function returns the length of a SUPER array given an object or array path.",
            "syntax": "get_array_length(super_expr)",
            "arguments": [
                {
                    "name": "super_expr",
                    "description": "A valid SUPER expression of array form.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "split_to_array",
            "description": "Uses a delimiter as an optional parameter. If no delimiter is present, then the default is a comma.",
            "syntax": "split_to_array(string,delimiter)",
            "arguments": [
                {
                    "name": "string",
                    "description": "The input string to be split.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "delimiter",
                    "description": "An optional value on which the input string will be split. The default is a comma.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SUBARRAY",
            "description": "Manipulates arrays to return a subset of the input arrays.",
            "syntax": "SUBARRAY(super_expr,start_position,length)",
            "arguments": [
                {
                    "name": "super_expr",
                    "description": "A valid SUPER expression in array form.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "start_position",
                    "description": "The position within the array to begin the extraction, starting at index position 0. A negative position counts backward from the end of the array.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "length",
                    "description": "The number of elements to extract (the length of the substring).",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "BIT_AND",
            "description": "The BIT_AND function runs bit-wise AND operations on all of the values in a single integer column or expression. This function aggregates each bit of each binary value that corresponds to each integer value in the expression. The BIT_AND function returns a result of0if none of the bits is set to 1 across all of the values. If one or more bits is set to 1 across all values, the function returns an integer value. This integer is the number that corresponds to the binary value for the those bits. For example, a table contains four integer values in a column: 3, 7, 10, and 22. These integers are represented in binary form as follows: A BIT_AND operation on this dataset finds that all bits are set to1in the second-to-last position only. The result is a binary value of00000010, which represents the integer value2. Therefore, the BIT_AND function returns2.",
            "syntax": "BIT_AND( [DISTINCT | ALL]expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The target column or expression that the function operates on. This expression must have an INT, INT2, or INT8 data type. The function returns an equivalent INT, INT2, or INT8 data type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "DISTINCT | ALL",
                    "description": "With the argument DISTINCT, the function eliminates all duplicate values for the specified expression before calculating the result. With the argument ALL, the function retains all duplicate values. ALL is the default. For more information, see DISTINCT support for bit-wise aggregations .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "BIT_OR",
            "description": "The BIT_OR function runs bit-wise OR operations on all of the values in a single integer column or expression. This function aggregates each bit of each binary value that corresponds to each integer value in the expression. For example, suppose that your table contains four integer values in a column: 3, 7, 10, and 22. These integers are represented in binary form as follows. If you apply the BIT_OR function to the set of integer values, the operation looks for any value in which a1is found in each position. In this case, a1exists in the last five positions for at least one of the values, yielding a binary result of00011111; therefore, the function returns31(or16 + 8 + 4 + 2 + 1).",
            "syntax": "BIT_OR( [DISTINCT | ALL]expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The target column or expression that the function operates on. This expression must have an INT, INT2, or INT8 data type. The function returns an equivalent INT, INT2, or INT8 data type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "DISTINCT | ALL",
                    "description": "With the argument DISTINCT, the function eliminates all duplicate values for the specified expression before calculating the result. With the argument ALL, the function retains all duplicate values. ALL is the default. For more information, see DISTINCT support for bit-wise aggregations .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "BOOL_AND",
            "description": "The BOOL_AND function operates on a single Boolean or integer column or expression. This function applies similar logic to the BIT_AND and BIT_OR functions. For this function, the return type is a Boolean value (trueorfalse). If all values in a set are true, the BOOL_AND function returnstrue(t). If any value is false, the function returnsfalse(f).",
            "syntax": "BOOL_AND( [DISTINCT | ALL]expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The target column or expression that the function operates on. This expression must have a BOOLEAN or integer data type. The return type of the function is BOOLEAN.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "DISTINCT | ALL",
                    "description": "With the argument DISTINCT, the function eliminates all duplicate values for the specified expression before calculating the result. With the argument ALL, the function retains all duplicate values. ALL is the default. For more information, see DISTINCT support for bit-wise aggregations .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "BOOL_OR",
            "description": "The BOOL_OR function operates on a single Boolean or integer column or expression. This function applies similar logic to the BIT_AND and BIT_OR functions. For this function, the return type is a Boolean value (true,false, orNULL). If one or more values in a set istrue, the BOOL_OR function returnstrue(t). If all values in a set arefalse, the function returnsfalse(f). NULL can be returned if the value is unknown.",
            "syntax": "BOOL_OR( [DISTINCT | ALL]expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The target column or expression that the function operates on. This expression must have a BOOLEAN or integer data type. The return type of the function is BOOLEAN.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "DISTINCT | ALL",
                    "description": "With the argument DISTINCT, the function eliminates all duplicate values for the specified expression before calculating the result. With the argument ALL, the function retains all duplicate values. ALL is the default. See DISTINCT support for bit-wise aggregations .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "C",
            "description": "The CASE expression is a conditional expression, similar to if/then/else statements found in other languages. CASE is used to specify a result when there are multiple conditions. Use CASE where a SQL expression is valid, such as in a SELECT command. There are two types of CASE expressions: simple and searched. In simple CASE expressions, an expression is compared with a value. When a match is found, the specified action in the THEN clause is applied. If no match is found, the action in the ELSE clause is applied. In searched CASE expressions, each CASE is evaluated based on a Boolean expression, and the CASE statement returns the first matching CASE. If no match is found among the WHEN clauses, the action in the ELSE clause is returned.",
            "syntax": "C(A",
            "arguments": [
                {
                    "name": "expression",
                    "description": "A column name or any valid expression.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "value",
                    "description": "Value that the expression is compared with, such as a numeric constant or a character string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "result",
                    "description": "The target value or expression that is returned when an expression or Boolean condition is evaluated. The data types of all the result expressions must be convertible to a single output type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "condition",
                    "description": "A Boolean expression that evaluates to true or false. If condition is true, the value of the CASE expression is the result that follows the condition, and the remainder of the CASE expression is not processed. If condition is false, any subsequent WHEN clauses are evaluated. If no WHEN condition results are true, the value of the CASE expression is the result of the ELSE clause. If the ELSE clause is omitted and no condition is true, the result is null.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "[",
            "description": "The CASE expression is a conditional expression, similar to if/then/else statements found in other languages. CASE is used to specify a result when there are multiple conditions. Use CASE where a SQL expression is valid, such as in a SELECT command. There are two types of CASE expressions: simple and searched. In simple CASE expressions, an expression is compared with a value. When a match is found, the specified action in the THEN clause is applied. If no match is found, the action in the ELSE clause is applied. In searched CASE expressions, each CASE is evaluated based on a Boolean expression, and the CASE statement returns the first matching CASE. If no match is found among the WHEN clauses, the action in the ELSE clause is returned.",
            "syntax": "[(E",
            "arguments": [
                {
                    "name": "expression",
                    "description": "A column name or any valid expression.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "value",
                    "description": "Value that the expression is compared with, such as a numeric constant or a character string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "result",
                    "description": "The target value or expression that is returned when an expression or Boolean condition is evaluated. The data types of all the result expressions must be convertible to a single output type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "condition",
                    "description": "A Boolean expression that evaluates to true or false. If condition is true, the value of the CASE expression is the result that follows the condition, and the remainder of the CASE expression is not processed. If condition is false, any subsequent WHEN clauses are evaluated. If no WHEN condition results are true, the value of the CASE expression is the result of the ELSE clause. If the ELSE clause is omitted and no condition is true, the result is null.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "E",
            "description": "The CASE expression is a conditional expression, similar to if/then/else statements found in other languages. CASE is used to specify a result when there are multiple conditions. Use CASE where a SQL expression is valid, such as in a SELECT command. There are two types of CASE expressions: simple and searched. In simple CASE expressions, an expression is compared with a value. When a match is found, the specified action in the THEN clause is applied. If no match is found, the action in the ELSE clause is applied. In searched CASE expressions, each CASE is evaluated based on a Boolean expression, and the CASE statement returns the first matching CASE. If no match is found among the WHEN clauses, the action in the ELSE clause is returned.",
            "syntax": "E(N",
            "arguments": [
                {
                    "name": "expression",
                    "description": "A column name or any valid expression.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "value",
                    "description": "Value that the expression is compared with, such as a numeric constant or a character string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "result",
                    "description": "The target value or expression that is returned when an expression or Boolean condition is evaluated. The data types of all the result expressions must be convertible to a single output type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "condition",
                    "description": "A Boolean expression that evaluates to true or false. If condition is true, the value of the CASE expression is the result that follows the condition, and the remainder of the CASE expression is not processed. If condition is false, any subsequent WHEN clauses are evaluated. If no WHEN condition results are true, the value of the CASE expression is the result of the ELSE clause. If the ELSE clause is omitted and no condition is true, the result is null.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "C",
            "description": "The CASE expression is a conditional expression, similar to if/then/else statements found in other languages. CASE is used to specify a result when there are multiple conditions. Use CASE where a SQL expression is valid, such as in a SELECT command. There are two types of CASE expressions: simple and searched. In simple CASE expressions, an expression is compared with a value. When a match is found, the specified action in the THEN clause is applied. If no match is found, the action in the ELSE clause is applied. In searched CASE expressions, each CASE is evaluated based on a Boolean expression, and the CASE statement returns the first matching CASE. If no match is found among the WHEN clauses, the action in the ELSE clause is returned.",
            "syntax": "C(A",
            "arguments": [
                {
                    "name": "expression",
                    "description": "A column name or any valid expression.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "value",
                    "description": "Value that the expression is compared with, such as a numeric constant or a character string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "result",
                    "description": "The target value or expression that is returned when an expression or Boolean condition is evaluated. The data types of all the result expressions must be convertible to a single output type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "condition",
                    "description": "A Boolean expression that evaluates to true or false. If condition is true, the value of the CASE expression is the result that follows the condition, and the remainder of the CASE expression is not processed. If condition is false, any subsequent WHEN clauses are evaluated. If no WHEN condition results are true, the value of the CASE expression is the result of the ELSE clause. If the ELSE clause is omitted and no condition is true, the result is null.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "W",
            "description": "The CASE expression is a conditional expression, similar to if/then/else statements found in other languages. CASE is used to specify a result when there are multiple conditions. Use CASE where a SQL expression is valid, such as in a SELECT command. There are two types of CASE expressions: simple and searched. In simple CASE expressions, an expression is compared with a value. When a match is found, the specified action in the THEN clause is applied. If no match is found, the action in the ELSE clause is applied. In searched CASE expressions, each CASE is evaluated based on a Boolean expression, and the CASE statement returns the first matching CASE. If no match is found among the WHEN clauses, the action in the ELSE clause is returned.",
            "syntax": "W(H",
            "arguments": [
                {
                    "name": "expression",
                    "description": "A column name or any valid expression.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "value",
                    "description": "Value that the expression is compared with, such as a numeric constant or a character string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "result",
                    "description": "The target value or expression that is returned when an expression or Boolean condition is evaluated. The data types of all the result expressions must be convertible to a single output type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "condition",
                    "description": "A Boolean expression that evaluates to true or false. If condition is true, the value of the CASE expression is the result that follows the condition, and the remainder of the CASE expression is not processed. If condition is false, any subsequent WHEN clauses are evaluated. If no WHEN condition results are true, the value of the CASE expression is the result of the ELSE clause. If the ELSE clause is omitted and no condition is true, the result is null.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "[",
            "description": "The CASE expression is a conditional expression, similar to if/then/else statements found in other languages. CASE is used to specify a result when there are multiple conditions. Use CASE where a SQL expression is valid, such as in a SELECT command. There are two types of CASE expressions: simple and searched. In simple CASE expressions, an expression is compared with a value. When a match is found, the specified action in the THEN clause is applied. If no match is found, the action in the ELSE clause is applied. In searched CASE expressions, each CASE is evaluated based on a Boolean expression, and the CASE statement returns the first matching CASE. If no match is found among the WHEN clauses, the action in the ELSE clause is returned.",
            "syntax": "[(E",
            "arguments": [
                {
                    "name": "expression",
                    "description": "A column name or any valid expression.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "value",
                    "description": "Value that the expression is compared with, such as a numeric constant or a character string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "result",
                    "description": "The target value or expression that is returned when an expression or Boolean condition is evaluated. The data types of all the result expressions must be convertible to a single output type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "condition",
                    "description": "A Boolean expression that evaluates to true or false. If condition is true, the value of the CASE expression is the result that follows the condition, and the remainder of the CASE expression is not processed. If condition is false, any subsequent WHEN clauses are evaluated. If no WHEN condition results are true, the value of the CASE expression is the result of the ELSE clause. If the ELSE clause is omitted and no condition is true, the result is null.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "E",
            "description": "The CASE expression is a conditional expression, similar to if/then/else statements found in other languages. CASE is used to specify a result when there are multiple conditions. Use CASE where a SQL expression is valid, such as in a SELECT command. There are two types of CASE expressions: simple and searched. In simple CASE expressions, an expression is compared with a value. When a match is found, the specified action in the THEN clause is applied. If no match is found, the action in the ELSE clause is applied. In searched CASE expressions, each CASE is evaluated based on a Boolean expression, and the CASE statement returns the first matching CASE. If no match is found among the WHEN clauses, the action in the ELSE clause is returned.",
            "syntax": "E(N",
            "arguments": [
                {
                    "name": "expression",
                    "description": "A column name or any valid expression.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "value",
                    "description": "Value that the expression is compared with, such as a numeric constant or a character string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "result",
                    "description": "The target value or expression that is returned when an expression or Boolean condition is evaluated. The data types of all the result expressions must be convertible to a single output type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "condition",
                    "description": "A Boolean expression that evaluates to true or false. If condition is true, the value of the CASE expression is the result that follows the condition, and the remainder of the CASE expression is not processed. If condition is false, any subsequent WHEN clauses are evaluated. If no WHEN condition results are true, the value of the CASE expression is the result of the ELSE clause. If the ELSE clause is omitted and no condition is true, the result is null.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DECODE",
            "description": "A DECODE expression replaces a specific value with either another specific value or a default value, depending on the result of an equality condition. This operation is equivalent to the operation of a simple CASE expression or an IF-THEN-ELSE statement.",
            "syntax": "DECODE(expression,search,result[,search,result]... [ ,default] )",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The source of the value that you want to compare, such as a column in a table.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "search",
                    "description": "The target value that is compared against the source expression, such as a numeric value or a character string. The search expression must evaluate to a single fixed value. You cannot specify an expression that evaluates to a range of values, such as age between 20 and 29 ; you need to specify separate search/result pairs for each value that you want to replace. The data type of all instances of the search expression must be the same or compatible. The expression and search parameters must also be compatible.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "result",
                    "description": "The replacement value that query returns when the expression matches the search value. You must include at least one search/result pair in the DECODE expression. The data types of all instances of the result expression must be the same or compatible. The result and default parameters must also be compatible.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "default",
                    "description": "An optional default value that is used for cases when the search condition fails. If you do not specify a default value, the DECODE expression returns NULL.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "GREATEST",
            "description": "Returns the largest or smallest value from a list of any number of expressions.",
            "syntax": "GREATEST(value[, ...])",
            "arguments": [
                {
                    "name": "expression_list",
                    "description": "A comma-separated list of expressions, such as column names. The expressions must all be convertible to a common data type. NULL values in the list are ignored. If all of the expressions evaluate to NULL, the result is NULL.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "LEAST",
            "description": "Returns the largest or smallest value from a list of any number of expressions.",
            "syntax": "LEAST(value[, ...])",
            "arguments": [
                {
                    "name": "expression_list",
                    "description": "A comma-separated list of expressions, such as column names. The expressions must all be convertible to a common data type. NULL values in the list are ignored. If all of the expressions evaluate to NULL, the result is NULL.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "NVL",
            "description": "Returns the value of the first expression that isn't null in a series of expressions. When a non-null value is found, the remaining expressions in the list aren't evaluated. NVL is identical to COALESCE. They are synonyms. This topic explains the syntax and contains examples for both.",
            "syntax": "NVL(expression,expression, ... )",
            "arguments": [
                {
                    "name": "expression",
                    "description": "An expression, such as a column name, to be evaluated for null status.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "COALESCE",
            "description": "Returns the value of the first expression that isn't null in a series of expressions. When a non-null value is found, the remaining expressions in the list aren't evaluated. NVL is identical to COALESCE. They are synonyms. This topic explains the syntax and contains examples for both.",
            "syntax": "COALESCE(expression,expression, ... )",
            "arguments": [
                {
                    "name": "expression",
                    "description": "An expression, such as a column name, to be evaluated for null status.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "NVL2",
            "description": "Returns one of two values based on whether a specified expression evaluates to NULL or NOT NULL.",
            "syntax": "NVL2(expression,not_null_return_value,null_return_value)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "An expression, such as a column name, to be evaluated for null status.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "not_null_return_value",
                    "description": "The value returned if expression evaluates to NOT NULL. The not_null_return_value value must either have the same data type as expression or be implicitly convertible to that data type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "null_return_value",
                    "description": "The value returned if expression evaluates to NULL. The null_return_value value must either have the same data type as expression or be implicitly convertible to that data type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "NULLIF",
            "description": "",
            "syntax": "NULLIF(expression1,expression2)",
            "arguments": [
                {
                    "name": "expression1, expression2",
                    "description": "The target columns or expressions that are compared. The return type is the same as the type of the first expression. The default column name of the NULLIF result is the column name of the first expression.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "CAST",
            "description": "The CAST function converts one data type to another compatible data type. For instance, you can convert a string to a date, or a numeric type to a string. CAST performs a runtime conversion, which means that the conversion doesn't change a value's data type in a source table. It's changed only in the context of the query. The CAST function is very similar toCONVERT function, in that they both convert one data type to another, but they are called differently. Certain data types require an explicit conversion to other data types using the CAST or CONVERT function. Other data types can be converted implicitly, as part of another command, without using CAST or CONVERT. SeeType compatibility and conversion.",
            "syntax": "CAST(expressionAStype)expression::type",
            "arguments": [
                {
                    "name": "expression",
                    "description": "An expression that evaluates to one or more values, such as a column name or a literal. Converting null values returns nulls. The expression cannot contain blank or empty strings.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "type",
                    "description": "One of the supported Data types .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TO_CHAR",
            "description": "TO_CHAR converts a timestamp or numeric expression to a character-string data format.",
            "syntax": "TO_CHAR(timestamp_expression|numeric_expression, 'format')",
            "arguments": [
                {
                    "name": "timestamp_expression",
                    "description": "An expression that results in a TIMESTAMP or TIMESTAMPTZ type value or a value that can implicitly be coerced to a timestamp.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "numeric_expression",
                    "description": "An expression that results in a numeric data type value or a value that can implicitly be coerced to a numeric type. For more information, see Numeric types . TO_CHAR inserts a space to the left of the numeral string. Note TO_CHAR does not support 128-bit DECIMAL values.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "format",
                    "description": "The format for the new value. For valid formats, see Datetime format strings and Numeric format strings .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TO_DATE",
            "description": "TO_DATE converts a date represented by a character string to a DATE data type.",
            "syntax": "TO_DATE(string,format)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A string to be converted.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "format",
                    "description": "A string literal that defines the format of the input string , in terms of its date parts. For a list of valid day, month, and year formats, see Datetime format strings .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "is_strict",
                    "description": "An optional Boolean value that specifies whether an error is returned if an input date value is out of range. When is_strict is set to TRUE , an error is returned if there is an out of range value. When is_strict is set to FALSE , which is the default, then overflow values are accepted.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TO_DATE",
            "description": "TO_DATE converts a date represented by a character string to a DATE data type.",
            "syntax": "TO_DATE(string,format,is_strict)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A string to be converted.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "format",
                    "description": "A string literal that defines the format of the input string , in terms of its date parts. For a list of valid day, month, and year formats, see Datetime format strings .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "is_strict",
                    "description": "An optional Boolean value that specifies whether an error is returned if an input date value is out of range. When is_strict is set to TRUE , an error is returned if there is an out of range value. When is_strict is set to FALSE , which is the default, then overflow values are accepted.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "to_number",
            "description": "TO_NUMBER converts a string to a numeric (decimal) value.",
            "syntax": "to_number(string,format)",
            "arguments": [
                {
                    "name": "string",
                    "description": "String to be converted. The format must be a literal value.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "format",
                    "description": "The second argument is a format string that indicates how the character string should be parsed to create the numeric value. For example, the format '99D999' specifies that the string to be converted consists of five digits with the decimal point in the third position. For example, to_number('12.345','99D999') returns 12.345 as a numeric value. For a list of valid formats, see Numeric format strings .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TEXT_TO_INT_ALT",
            "description": "TEXT_TO_INT_ALT converts a character string to an integer using Teradata-style formatting. Fraction digits in the result are truncated.",
            "syntax": "TEXT_TO_INT_ALT(expression[ , 'format'])",
            "arguments": [
                {
                    "name": "expression",
                    "description": "An expression that results in one or more CHAR or VARCHAR values, such as a column name or literal string. Converting null values returns nulls. The function converts blank or empty strings to 0.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "format",
                    "description": "A string literal that defines the format of the input expression. For more information about the formatting characters you can specify, see Teradata-style formatting characters for numeric data .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TEXT_TO_NUMERIC_ALT",
            "description": "TEXT_TO_NUMERIC_ALT performs a Teradata-style cast operation to convert a character string to a numeric data format.",
            "syntax": "TEXT_TO_NUMERIC_ALT(expression[, 'format'] [,precision,scale])",
            "arguments": [
                {
                    "name": "expression",
                    "description": "An expression that evaluates to one or more CHAR or VARCHAR values, such as a column name or a literal. Converting null values returns nulls. Blank or empty strings are converted to 0.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "format",
                    "description": "A string literal that defines the format of the input expression. For more information, see Teradata-style formatting characters for numeric data .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "precision",
                    "description": "The number of digits in the numeric result. The default is 38.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "scale",
                    "description": "The number of digits to the right of the decimal point in the numeric result. The default is 0.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "d",
            "description": "Concatenates a DATE to a TIME or TIMETZ  on either side of the + symbol and returns a TIMESTAMP or TIMESTAMPTZ.",
            "syntax": "d(a",
            "arguments": [
                {
                    "name": "date",
                    "description": "A column of data type DATE or an expression that implicitly evaluates to a DATE type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "time",
                    "description": "A column of data type TIME or an expression that implicitly evaluates to a TIME type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "timetz",
                    "description": "A column of data type TIMETZ or an expression that implicitly evaluates to a TIMETZ type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ADD_MONTHS",
            "description": "ADD_MONTHS adds the specified number of months to a date or timestamp value or expression. TheDATEADDfunction provides similar functionality.",
            "syntax": "ADD_MONTHS({date|timestamp},integer)",
            "arguments": [
                {
                    "name": "date|timestamp",
                    "description": "A column of data type DATE or TIMESTAMP or an expression that implicitly evaluates to a DATE or TIMESTAMP type. If the date is the last day of the month, or if the resulting month is shorter, the function returns the last day of the month in the result. For other dates, the result contains the same day number as the date expression.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "integer",
                    "description": "A value of data type INTEGER . Use a negative number to subtract months from dates.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "A",
            "description": "AT TIME ZONE specifies which time zone to use with a TIMESTAMP or TIMESTAMPTZ expression.",
            "syntax": "A(T",
            "arguments": [
                {
                    "name": "timezone",
                    "description": "The TIMEZONE for the return value. The time zone can be specified as a time zone name (such as 'Africa/Kampala' or 'Singapore' ) or as a time zone abbreviation (such as 'UTC' or 'PDT' ). To view a list of supported time zone names, run the following command. select pg_timezone_names ( ) ; To view a list of supported time zone abbreviations, run the following command. select pg_timezone_abbrevs ( ) ; For more information and examples, see Time zone usage notes .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "CONVERT_TIMEZONE",
            "description": "CONVERT_TIMEZONE converts a timestamp from one time zone to another. The function automatically adjusts for daylight saving time.",
            "syntax": "CONVERT_TIMEZONE( ['source_timezone',] 'target_timezone', 'timestamp')",
            "arguments": [
                {
                    "name": "source_timezone",
                    "description": "(Optional) The time zone of the current timestamp. The default is UTC. For more information, see Time zone usage notes .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "target_timezone",
                    "description": "The time zone for the new timestamp. For more information, see Time zone usage notes .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "C",
            "description": "CURRENT_DATE returns a date in the current session time zone (UTC by default) in the default format: YYYY-MM-DD. CURRENT_DATE returns the start date for the current transaction, not for the start of the current statement. Consider the scenario where you start a transaction containing multiple statements on 10/01/08 23:59, and the statement containing CURRENT_DATE runs at 10/02/08 00:00. CURRENT_DATE returns10/01/08, not10/02/08.",
            "syntax": "C(U",
            "arguments": null
        },
        {
            "name": "DATE_CMP",
            "description": "DATE_CMP compares two dates. The function returns0if the dates are identical,1ifdate1is greater, and-1ifdate2is greater.",
            "syntax": "DATE_CMP(date1, date2)",
            "arguments": [
                {
                    "name": "date1",
                    "description": "A column of data type DATE or an expression that evaluates to a DATE type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "date2",
                    "description": "A column of data type DATE or an expression that evaluates to a DATE type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DATE_CMP_TIMESTAMP",
            "description": "DATE_CMP_TIMESTAMP compares a date to a timestamp and returns0if the values are identical,1ifdateis greater chronologically and-1iftimestampis greater.",
            "syntax": "DATE_CMP_TIMESTAMP(date,timestamp)",
            "arguments": [
                {
                    "name": "date",
                    "description": "A column of data type DATE or an expression that evaluates to a DATE type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "timestamp",
                    "description": "A column of data type TIMESTAMP or an expression that evaluates to a TIMESTAMP type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DATE_CMP_TIMESTAMPTZ",
            "description": "DATE_CMP_TIMESTAMPTZ compares a date to a timestamp with time zone and returns0if the values are identical,1ifdateis greater chronologically and-1iftimestamptzis greater.",
            "syntax": "DATE_CMP_TIMESTAMPTZ(date,timestamptz)",
            "arguments": [
                {
                    "name": "date",
                    "description": "A column of data type DATE or an expression that implicitly evaluates to a DATE type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "timestamptz",
                    "description": "A column of data type TIMESTAMPTZ or an expression that implicitly evaluates to a TIMESTAMPTZ type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DATEADD",
            "description": "Increments a DATE, TIME, TIMETZ, or TIMESTAMP value by a specified interval.",
            "syntax": "DATEADD(datepart,interval,{date|time|timetz|timestamp} )",
            "arguments": [
                {
                    "name": "datepart",
                    "description": "The date part (year, month, day, or hour, for example) that the function operates on. For more information, see Date parts for date or timestamp functions .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "interval",
                    "description": "An integer that specified the interval (number of days, for example) to add to the target expression. A negative integer subtracts the interval.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "date|time|timetz|timestamp",
                    "description": "A DATE, TIME, TIMETZ, or TIMESTAMP column or an expression that implicitly converts to a DATE, TIME, TIMETZ, or TIMESTAMP. The DATE, TIME, TIMETZ, or TIMESTAMP expression must contain the specified date part.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DATEDIFF",
            "description": "DATEDIFF returns the difference between the date parts of two date or time expressions.",
            "syntax": "DATEDIFF(datepart,{date|time|timetz|timestamp},{date|time|timetz|timestamp} )",
            "arguments": [
                {
                    "name": "datepart",
                    "description": "The specific part of the date or time value (year, month, or day, hour, minute, second, millisecond, or microsecond) that the function operates on. For more information, see Date parts for date or timestamp functions . Specifically, DATEDIFF determines the number of date part boundaries that are crossed between two expressions. For example, suppose that you're calculating the difference in years between two dates, 12-31-2008 and 01-01-2009 . In this case, the function returns 1 year despite the fact that these dates are only one day apart. If you are finding the difference in hours between two timestamps, 01-01-2009 8:30:00 and 01-01-2009 10:00:00 , the result is 2 hours. If you are finding the difference in hours between two timestamps, 8:30:00 and 10:00:00 , the result is 2 hours.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "date|time|timetz|timestamp",
                    "description": "A DATE, TIME, TIMETZ, or TIMESTAMP column or expressions that implicitly convert to a DATE, TIME, TIMETZ, or TIMESTAMP. The expressions must both contain the specified date or time part. If the second date or time is later than the first date or time, the result is positive. If the second date or time is earlier than the first date or time, the result is negative.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DATE_PART",
            "description": "DATE_PART extracts date part values from an expression. DATE_PART is a synonym of the PGDATE_PART function.",
            "syntax": "DATE_PART(datepart,{date|timestamp})",
            "arguments": [
                {
                    "name": "datepart",
                    "description": "An identifier literal or string of the specific part of the date value (for example, year, month, or day) that the function operates on. For more information, see Date parts for date or timestamp functions .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "{date|timestamp}",
                    "description": "A date column, timestamp column, or an expression that implicitly converts to a date or timestamp. The column or expression in date or timestamp must contain the date part specified in datepart .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DATE_PART_YEAR",
            "description": "The DATE_PART_YEAR function extracts the year from a date.",
            "syntax": "DATE_PART_YEAR(date)",
            "arguments": [
                {
                    "name": "date",
                    "description": "A column of data type DATE or an expression that implicitly evaluates to a DATE type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DATE_TRUNC",
            "description": "The DATE_TRUNC function truncates a timestamp expression or literal based on the date part that you specify, such as hour, day, or month.",
            "syntax": "DATE_TRUNC('datepart',timestamp)",
            "arguments": [
                {
                    "name": "datepart",
                    "description": "The date part to which to truncate the timestamp value. The input timestamp is truncated to the precision of the input datepart . For example, month truncates to the first day of the month. Valid formats are as follows: microsecond, microseconds millisecond, milliseconds second, seconds minute, minutes hour, hours day, days week, weeks month, months quarter, quarters year, years decade, decades century, centuries millennium, millennia For more information about abbreviations of some formats, see Date parts for date or timestamp functions",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "timestamp",
                    "description": "A timestamp column or an expression that implicitly converts to a timestamp.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "EXTRACT",
            "description": "The EXTRACT function returns a date or time part from a TIMESTAMP, TIMESTAMPTZ, TIME, TIMETZ, INTERVAL YEAR TO MONTH, or INTERVAL DAY TO SECOND value. Examples include a day, month, year, hour, minute, second, millisecond, or microsecond from a timestamp.",
            "syntax": "EXTRACT(datepartFROMsource)",
            "arguments": [
                {
                    "name": "datepart",
                    "description": "The subfield of a date or time to extract, such as a day, month, year, hour, minute, second, millisecond, or microsecond. For possible values, see Date parts for date or timestamp functions .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "source",
                    "description": "A column or expression that evaluates to a data type of TIMESTAMP, TIMESTAMPTZ, TIME, TIMETZ, INTERVAL YEAR TO MONTH, or INTERVAL DAY TO SECOND.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "GETDATE",
            "description": "GETDATE returns the current date and time in the current session time zone (UTC by default). It returns the start date or time of the current statement, even when it is within a transaction block.",
            "syntax": "GETDATE()",
            "arguments": null
        },
        {
            "name": "INTERVAL_CMP",
            "description": "INTERVAL_CMP compares two intervals and returns1if the first interval is greater,-1if the second interval is greater, and0if the intervals are equal. For more information, seeExamples of interval literals without qualifier syntax.",
            "syntax": "INTERVAL_CMP(interval1, interval2)",
            "arguments": [
                {
                    "name": "interval1",
                    "description": "An interval literal value.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "interval2",
                    "description": "An interval literal value.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "LAST_DAY",
            "description": "LAST_DAY returns the date of the last day of the month that containsdate. The return type is always DATE, regardless of the data type of thedateargument. For more information about retrieving specific date parts, seeDATE_TRUNC function.",
            "syntax": "LAST_DAY({date|timestamp} )",
            "arguments": null
        },
        {
            "name": "MONTHS_BETWEEN",
            "description": "MONTHS_BETWEEN determines the number of months between two dates. If the first date is later than the second date, the result is positive; otherwise, the result is negative. If either argument is null, the result is NULL.",
            "syntax": "MONTHS_BETWEEN(date1,date2)",
            "arguments": [
                {
                    "name": "date1",
                    "description": "A column of data type DATE or an expression that implicitly evaluates to a DATE type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "date2",
                    "description": "A column of data type DATE or an expression that implicitly evaluates to a DATE type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "NEXT_DAY",
            "description": "NEXT_DAY returns the date of the first instance of the specified day that is later than the given date. If thedayvalue is the same day of the week as the given date, the next occurrence of that day is returned.",
            "syntax": "NEXT_DAY({date|timestamp},day)",
            "arguments": [
                {
                    "name": "date|timestamp",
                    "description": "A column of data type DATE or TIMESTAMP or an expression that implicitly evaluates to a DATE or TIMESTAMP type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "day",
                    "description": "A string containing the name of any day. Capitalization doesn't matter. Valid values are as follows. Day Values Sunday Su, Sun, Sunday Monday M, Mo, Mon, Monday Tuesday Tu, Tue, Tues, Tuesday Wednesday W, We, Wed, Wednesday Thursday Th, Thu, Thurs, Thursday Friday F, Fr, Fri, Friday Saturday Sa, Sat, Saturday",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "S",
            "description": "SYSDATE returns the current date and time in the current session time zone (UTC by default). SYSDATE returns the start date and time for the current transaction, not for the start of the current statement.",
            "syntax": "S(Y",
            "arguments": null
        },
        {
            "name": "TIMEOFDAY",
            "description": "TIMEOFDAY is a special alias used to return the weekday, date, and time as a string value. It returns the time of day string for the current statement, even when it is within a transaction block.",
            "syntax": "TIMEOFDAY()",
            "arguments": null
        },
        {
            "name": "TIMESTAMP_CMP",
            "description": "Compares the value of two timestamps and returns an integer. If the timestamps are identical, the function returns0. If the first timestamp is greater, the function returns1. If the second timestamp is greater, the function returns-1.",
            "syntax": "TIMESTAMP_CMP(timestamp1,timestamp2)",
            "arguments": [
                {
                    "name": "timestamp1",
                    "description": "A column of data type TIMESTAMP or an expression that implicitly evaluates to a TIMESTAMP type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "timestamp2",
                    "description": "A column of data type TIMESTAMP or an expression that implicitly evaluates to a TIMESTAMP type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TIMESTAMP_CMP_DATE",
            "description": "TIMESTAMP_CMP_DATE compares the value of a timestamp and a date. If the timestamp and date values are identical, the function returns0. If the timestamp is greater chronologically, the function returns1. If the date is greater, the function returns-1.",
            "syntax": "TIMESTAMP_CMP_DATE(timestamp,date)",
            "arguments": [
                {
                    "name": "timestamp",
                    "description": "A column of data type TIMESTAMP or an expression that implicitly evaluates to a TIMESTAMP type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "date",
                    "description": "A column of data type DATE or an expression that implicitly evaluates to a DATE type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TIMESTAMP_CMP_TIMESTAMPTZ",
            "description": "TIMESTAMP_CMP_TIMESTAMPTZ compares the value of a timestamp expression with a timestamp with time zone expression. If the timestamp and timestamp with time zone values are identical, the function returns0. If the timestamp is greater chronologically, the function returns1. If the timestamp with time zone is greater, the function returns\u20131.",
            "syntax": "TIMESTAMP_CMP_TIMESTAMPTZ(timestamp,timestamptz)",
            "arguments": [
                {
                    "name": "timestamp",
                    "description": "A column of data type TIMESTAMP or an expression that implicitly evaluates to a TIMESTAMP type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "timestamptz",
                    "description": "A column of data type TIMESTAMPTZ or an expression that implicitly evaluates to a TIMESTAMPTZ type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TIMESTAMPTZ_CMP",
            "description": "TIMESTAMPTZ_CMP compares the value of two timestamp with time zone values and returns an integer. If the timestamps are identical, the function returns0. If the first timestamp is greater chronologically, the function returns1. If the second timestamp is greater, the function returns\u20131.",
            "syntax": "TIMESTAMPTZ_CMP(timestamptz1, timestamptz2)",
            "arguments": [
                {
                    "name": "timestamptz1",
                    "description": "A column of data type TIMESTAMPTZ or an expression that implicitly evaluates to a TIMESTAMPTZ type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "timestamptz2",
                    "description": "A column of data type TIMESTAMPTZ or an expression that implicitly evaluates to a TIMESTAMPTZ type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TIMESTAMPTZ_CMP_DATE",
            "description": "TIMESTAMPTZ_CMP_DATE compares the value of a timestamp and a date. If the timestamp and date values are identical, the function returns0. If the timestamp is greater chronologically, the function returns1. If the date is greater, the function returns\u20131.",
            "syntax": "TIMESTAMPTZ_CMP_DATE(timestamptz, date)",
            "arguments": [
                {
                    "name": "timestamptz",
                    "description": "A column of data type TIMESTAMPTZ or an expression that implicitly evaluates to a TIMESTAMPTZ type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "date",
                    "description": "A column of data type DATE or an expression that implicitly evaluates to a DATE type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TIMESTAMPTZ_CMP_TIMESTAMP",
            "description": "TIMESTAMPTZ_CMP_TIMESTAMP compares the value of a timestamp with time zone expression with a timestamp expression. If the timestamp with time zone and timestamp values are identical, the function returns0. If the timestamp with time zone is greater chronologically, the function returns1. If the timestamp is greater, the function returns\u20131.",
            "syntax": "TIMESTAMPTZ_CMP_TIMESTAMP(timestamptz,timestamp)",
            "arguments": [
                {
                    "name": "timestamptz",
                    "description": "A column of data type TIMESTAMPTZ or an expression that implicitly evaluates to a TIMESTAMPTZ type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "timestamp",
                    "description": "A column of data type TIMESTAMP or an expression that implicitly evaluates to a TIMESTAMP type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TIMEZONE",
            "description": "TIMEZONE returns a timestamp for the specified time zone and timestamp value. For information and examples about how to set time zone, seetimezone. For information and examples about how to convert time zone, seeCONVERT_TIMEZONE.",
            "syntax": "TIMEZONE('timezone',{timestamp|timestamptz})",
            "arguments": [
                {
                    "name": "timezone",
                    "description": "The time zone for the return value. The time zone can be specified as a time zone name (such as 'Africa/Kampala' or 'Singapore' ) or as a time zone abbreviation (such as 'UTC' or 'PDT' ). To view a list of supported time zone names, run the following command. select pg_timezone_names ( ) ; To view a list of supported time zone abbreviations, run the following command. select pg_timezone_abbrevs ( ) ; For more information and examples, see Time zone usage notes .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "timestamp|timestamptz",
                    "description": "An expression that results in a TIMESTAMP or TIMESTAMPTZ type, or a value that can implicitly be coerced to a timestamp or a timestamp with time zone.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "to_timestamp",
            "description": "TO_TIMESTAMP converts a TIMESTAMP string to TIMESTAMPTZ. For a list of additional date and time functions for Amazon Redshift, seeDate and time functions.",
            "syntax": "to_timestamp(timestamp,format)",
            "arguments": [
                {
                    "name": "timestamp",
                    "description": "A string that represents a timestamp value in the format specified by format . If this argument is left as empty, the timestamp value defaults to 0001-01-01 00:00:00 .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "format",
                    "description": "A string literal that defines the format of the timestamp value. Formats that include a time zone ( TZ , tz , or OF ) are not supported as input. For valid timestamp formats, see Datetime format strings .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "is_strict",
                    "description": "An optional Boolean value that specifies whether an error is returned if an input timestamp value is out of range. When is_strict is set to TRUE, an error is returned if there is an out of range value. When is_strict is set to FALSE, which is the default, then overflow values are accepted.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "to_timestamp",
            "description": "TO_TIMESTAMP converts a TIMESTAMP string to TIMESTAMPTZ. For a list of additional date and time functions for Amazon Redshift, seeDate and time functions.",
            "syntax": "to_timestamp(timestamp,format,is_strict)",
            "arguments": [
                {
                    "name": "timestamp",
                    "description": "A string that represents a timestamp value in the format specified by format . If this argument is left as empty, the timestamp value defaults to 0001-01-01 00:00:00 .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "format",
                    "description": "A string literal that defines the format of the timestamp value. Formats that include a time zone ( TZ , tz , or OF ) are not supported as input. For valid timestamp formats, see Datetime format strings .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "is_strict",
                    "description": "An optional Boolean value that specifies whether an error is returned if an input timestamp value is out of range. When is_strict is set to TRUE, an error is returned if there is an out of range value. When is_strict is set to FALSE, which is the default, then overflow values are accepted.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TRUNC",
            "description": "Truncates aTIMESTAMPand returns aDATE. This function can also truncate a number. For more information, seeTRUNC function.",
            "syntax": "TRUNC(timestamp)",
            "arguments": [
                {
                    "name": "timestamp",
                    "description": "A column of data type TIMESTAMP or an expression that implicitly evaluates to a TIMESTAMP type. To return a timestamp value with 00:00:00 as the time, cast the function result to a TIMESTAMP .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "CHECKSUM",
            "description": "Computes a checksum value for building a hash index.",
            "syntax": "CHECKSUM(expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The input expression must be a VARCHAR, INTEGER, or DECIMAL data type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "farmFingerprint64",
            "description": "Computes the farmhash value of the input argument using theFingerprint64function.",
            "syntax": "farmFingerprint64(expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The input expression must be a VARCHAR or VARBYTE data type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "FNV_HASH",
            "description": "Computes the 64-bit FNV-1a non-cryptographic hash function for all basic data types.",
            "syntax": "FNV_HASH(value[, seed])",
            "arguments": [
                {
                    "name": "value",
                    "description": "The input value to be hashed. Amazon Redshift uses the binary representation of the value to hash the input value; for instance, INTEGER values are hashed using 4 bytes and BIGINT values are hashed using 8 bytes. Also, hashing CHAR and VARCHAR inputs does not ignore trailing spaces.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "seed",
                    "description": "The BIGINT seed of the hash function is optional. If not given, Amazon Redshift uses the default FNV seed. This enables combining the hash of multiple columns without any conversions or concatenations.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "MD5",
            "description": "Uses the MD5 cryptographic hash function to convert a variable-length string into a 32-character string that is a text representation of the hexadecimal value of a 128-bit checksum.",
            "syntax": "MD5(string)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A variable-length string.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SHA1",
            "description": "The SHA1 function uses the SHA1 cryptographic hash function to convert a variable-length string into a 40-character string that is a text representation of the hexadecimal value of a 160-bit checksum.",
            "syntax": "SHA1(string)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A variable-length string.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SHA2",
            "description": "The SHA2 function uses the SHA2 cryptographic hash function to convert a variable-length string into a character string. The character string is a text representation of the hexadecimal value of the checksum with the specified number of bits.",
            "syntax": "SHA2(string, bits)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A variable-length string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "integer",
                    "description": "The number of bits in the hash functions. Valid values are 0 (same as 256), 224, 256, 384, and 512.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "MURMUR3_32_HASH",
            "description": "The MURMUR3_32_HASH function computes the 32-bit Murmur3A non-cryptographic hash for all common data types including numeric and string types.",
            "syntax": "MURMUR3_32_HASH(value[, seed])",
            "arguments": [
                {
                    "name": "value",
                    "description": "The input value to hash. Amazon Redshift hashes the binary representation of the input value. This behavior is similar to FNV_HASH function , but the value is converted to the binary representation specified by the Apache Iceberg 32-bit Murmur3 hash specification .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "seed",
                    "description": "The INT seed of the hash function. This argument is optional. If not given, Amazon Redshift uses the default seed of 0. This enables combining the hash of multiple columns without any conversions or concatenations.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "HLL",
            "description": "The HLL function returns the HyperLogLog cardinality of the input expression values. The HLL function works with any data types except the HLLSKETCH data type. The HLL function ignores NULL values. When there are no rows in a table or all rows are NULL, the resulting cardinality is 0.",
            "syntax": "HLL(aggregate_expression)",
            "arguments": [
                {
                    "name": "aggregate_expression",
                    "description": "Any valid expression that provides the value to an aggregate, such as a column name. This function supports any data type as input except HLLSKETCH, GEOMETRY, GEOGRAPHY, and VARBYTE.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "HLL_CREATE_SKETCH",
            "description": "The HLL_CREATE_SKETCH function returns an HLLSKETCH data type that encapsulates the input expression values. The HLL_CREATE_SKETCH function works with any data type and ignores NULL values. When there are no rows in a table or all rows are NULL, the resulting sketch has no index-value pairs such as{\"version\":1,\"logm\":15,\"sparse\":{\"indices\":[],\"values\":[]}}.",
            "syntax": "HLL_CREATE_SKETCH(aggregate_expression)",
            "arguments": [
                {
                    "name": "aggregate_expression",
                    "description": "Any valid expression that provides the value to an aggregate, such as a column name. NULL values are ignored. This function supports any data type as input except HLLSKETCH, GEOMETRY, GEOGRAPHY, and VARBYTE.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "HLL_CARDINALITY",
            "description": "The HLL_CARDINALITY function returns the cardinality of the input HLLSKETCH data type.",
            "syntax": "HLL_CARDINALITY(hllsketch_expression)",
            "arguments": [
                {
                    "name": "hllsketch_expression",
                    "description": "Any valid expression that evaluates to an HLLSKETCH type, such as a column name. The input value is the HLLSKETCH data type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "HLL_COMBINE",
            "description": "The HLL_COMBINE aggregate function returns an HLLSKETCH data type that combines all input HLLSKETCH values. The combination of two or more HyperLogLog sketches is a new HLLSKETCH that encapsulates information about the union of the distinct values that each input sketch represents. After combining sketches, Amazon Redshift extracts the cardinality of the union of two or more datasets. For more information on how to combine multiple sketches, seeExample: Return a HyperLogLog sketch from combining multiple sketches.",
            "syntax": "HLL_COMBINE(hllsketch_expression)",
            "arguments": [
                {
                    "name": "hllsketch_expression",
                    "description": "Any valid expression that evaluates to an HLLSKETCH type, such as a column name. The input value is the HLLSKETCH data type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "HLL_COMBINE_SKETCHES",
            "description": "The HLL_COMBINE_SKETCHES is a scalar function that takes as input two HLLSKETCH values and combines them into a single HLLSKETCH. The combination of two or more HyperLogLog sketches is a new HLLSKETCH that encapsulates information about the union of the distinct values that each input sketch represents.",
            "syntax": "HLL_COMBINE_SKETCHES(hllsketch_expression1,hllsketch_expression2)",
            "arguments": [
                {
                    "name": "hllsketch_expression1andhllsketch_expression2",
                    "description": "Any valid expression that evaluates to an HLLSKETCH type, such as a column name.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "IS_VALID_JSON",
            "description": "The IS_VALID_JSON function validates a JSON string. The function returns Booleantrueif the string is properly formed JSON orfalseif the string is malformed. To validate a JSON array, useIS_VALID_JSON_ARRAY function For more information, seeJSON functions.",
            "syntax": "IS_VALID_JSON('json_string')",
            "arguments": [
                {
                    "name": "json_string",
                    "description": "A string or expression that evaluates to a JSON string.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "IS_VALID_JSON_ARRAY",
            "description": "The IS_VALID_JSON_ARRAY function validates a JSON array. The function returns Booleantrueif the array is properly formed JSON orfalseif the array is malformed. To validate a JSON string, useIS_VALID_JSON function For more information, seeJSON functions.",
            "syntax": "IS_VALID_JSON_ARRAY('json_array')",
            "arguments": [
                {
                    "name": "json_array",
                    "description": "A string or expression that evaluates to a JSON array.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "JSON_ARRAY_LENGTH",
            "description": "The JSON_ARRAY_LENGTH function returns the number of elements in the outer array of a JSON string. If thenull_if_invalidargument is set totrueand the JSON string is invalid, the function returnsNULLinstead of returning an error. For more information, seeJSON functions.",
            "syntax": "JSON_ARRAY_LENGTH('json_array' [,null_if_invalid] )",
            "arguments": [
                {
                    "name": "json_array",
                    "description": "A properly formatted JSON array.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "null_if_invalid",
                    "description": "(Optional) A BOOLEAN value that specifies whether to return NULL if the input JSON string is invalid instead of returning an error. To return NULL if the JSON is invalid, specify true ( t ). To return an error if the JSON is invalid, specify false ( f ). The default is false .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "JSON_EXTRACT_ARRAY_ELEMENT_TEXT",
            "description": "The JSON_EXTRACT_ARRAY_ELEMENT_TEXT function returns a JSON array element in the outermost array of a JSON string, using a zero-based index. The first element in an array is at position 0. If the index is negative or out of bound, JSON_EXTRACT_ARRAY_ELEMENT_TEXT returns empty string. If thenull_if_invalidargument is set totrueand the JSON string is invalid, the function returnsNULLinstead of returning an error. For more information, seeJSON functions.",
            "syntax": "JSON_EXTRACT_ARRAY_ELEMENT_TEXT('json string',pos[,null_if_invalid] )",
            "arguments": [
                {
                    "name": "json_string",
                    "description": "A properly formatted JSON string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "pos",
                    "description": "An INTEGER representing the index of the array element to be returned, using a zero-based array index.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "JSON_EXTRACT_PATH_TEXT",
            "description": "The JSON_EXTRACT_PATH_TEXT function returns the value for the key-value pair referenced by a series of path elements in a JSON string. The JSON path can be nested up to five levels deep. Path elements are case-sensitive. If a path element does not exist in the JSON string, JSON_EXTRACT_PATH_TEXT returnsNULL. If thenull_if_invalidargument is set totrueand the JSON string is invalid, the function returnsNULLinstead of returning an error. For information about additional JSON functions, seeJSON functions. For more information about working with JSON, seeCOPY from JSON format.",
            "syntax": "JSON_EXTRACT_PATH_TEXT('json_string', 'path_elem' [,'path_elem'[, \u2026] ] [,null_if_invalid] )",
            "arguments": [
                {
                    "name": "json_string",
                    "description": "A properly formatted JSON string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "path_elem",
                    "description": "A path element in a JSON string. One path element is required. Additional path elements can be specified, up to five levels deep.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "JSON_PARSE",
            "description": "The JSON_PARSE function parses data in JSON format and converts it into theSUPERrepresentation. To ingest intoSUPERdata type using the INSERT or UPDATE command, use the JSON_PARSE function. When you use JSON_PARSE() to parse JSON strings intoSUPERvalues, certain restrictions apply. For additional information, seeParsing options for SUPER.",
            "syntax": "JSON_PARSE({json_string|binary_value} )",
            "arguments": [
                {
                    "name": "json_string",
                    "description": "An expression that returns serialized JSON as a VARBYTE or VARCHAR type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "binary_value",
                    "description": "A VARBYTE type binary value.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "CAN_JSON_PARSE",
            "description": "The CAN_JSON_PARSE function parses data in JSON format and returnstrueif the result can be converted to aSUPERvalue using the JSON_PARSE function.",
            "syntax": "CAN_JSON_PARSE({json_string|binary_value} )",
            "arguments": [
                {
                    "name": "json_string",
                    "description": "An expression that returns serialized JSON in the VARBYTE or VARCHAR form.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "binary_value",
                    "description": "A VARBYTE type binary value.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "JSON_SERIALIZE",
            "description": "The JSON_SERIALIZE function serializes aSUPERexpression into textual JSON representation to follow RFC 8259. For more information on that RFC, seeThe JavaScript Object Notation (JSON) Data Interchange Format. TheSUPERsize limit is approximately the same as the block limit, and theVARCHARlimit is smaller than theSUPERsize limit. Therefore, the JSON_SERIALIZE function returns an error when the JSON format exceeds the varchar limit of the system. To check the size of aSUPERexpression, see theJSON_SIZEfunction.",
            "syntax": "JSON_SERIALIZE(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "JSON_SERIALIZE_TO_VARBYTE",
            "description": "The JSON_SERIALIZE_TO_VARBYTE function converts aSUPERvalue to a JSON string similar to JSON_SERIALIZE(), but stored in aVARBYTEvalue instead.",
            "syntax": "JSON_SERIALIZE_TO_VARBYTE(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "EXPLAIN_MODEL",
            "description": "The EXPLAIN_MODEL function returns a SUPER data type that contains a model explainability report in a JSON format. The explainability report contains information about the Shapley value for all model features. The EXPLAIN_MODEL function currently supports only the AUTO ON or AUTO OFF XGBoost models. When the explainability report isn't available, the function returns statuses showing on the progress of the model. These includeWaiting for training job to complete,Waiting for processing job to complete, andProcessing job failed. When you run the CREATE MODEL statement, the explanation state becomesWaiting for training job to complete. When the model has been trained and an explanation request is sent, the explanation state becomesWaiting for processing job to complete. When the model explanation completes successfully, the full explainability report is available. Otherwise, the state becomesProcessing job failed. When you run the CREATE MODEL statement, you can use the optionalMAX_RUNTIMEparameter to specify the maximum amount of time the training should take. Once model creation reaches that amount of time, Amazon Redshift stops creating the model. If you reach that time limit while creating an autopilot model, Amazon Redshift will return the best model so far. Model explainability becomes available once the model training finishes, so ifMAX_RUNTIMEis set to a low amount of time, the explainability report might not be available. Training time varies and depends on model complexity, data size, and other factors.",
            "syntax": "EXPLAIN_MODEL('schema_name.model_name')",
            "arguments": [
                {
                    "name": "schema_name",
                    "description": "The name of the schema. If no schema_name is specified, then the current schema is selected.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "model_name",
                    "description": "The name of the model. The model name in a schema must be unique.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ABS",
            "description": "ABS calculates the absolute value of a number, where that number can be a literal or an expression that evaluates to a number.",
            "syntax": "ABS(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "Number or expression that evaluates to a number. It can be the SMALLINT , INTEGER , BIGINT , DECIMAL , FLOAT4 , FLOAT8 , or SUPER type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ACOS",
            "description": "ACOS is a trigonometric function that returns the arc cosine of a number.  The return value is in radians and is between0andPI.",
            "syntax": "ACOS(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "The input parameter is a DOUBLE PRECISION number.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ASIN",
            "description": "ASIN is a trigonometric function that returns the arc sine of a number. The return value is in radians and is betweenPI/2and-PI/2.",
            "syntax": "ASIN(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "The input parameter is a DOUBLE PRECISION number.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ATAN",
            "description": "ATAN is a trigonometric function that returns the arc tangent of a number.  The return value is in radians and is between-PIandPI.",
            "syntax": "ATAN(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "The input parameter is a DOUBLE PRECISION number.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ATAN2",
            "description": "ATAN2 is a trigonometric function that returns the arc tangent of one number divided by another number. The return value is in radians and is betweenPI/2and-PI/2.",
            "syntax": "ATAN2(number1,number2)",
            "arguments": [
                {
                    "name": "number1",
                    "description": "A DOUBLE PRECISION number.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "number2",
                    "description": "A DOUBLE PRECISION number.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "CBRT",
            "description": "The CBRT function is a mathematical function that calculates the cube root of a given number.",
            "syntax": "CBRT(number)",
            "arguments": null
        },
        {
            "name": "{CEIL",
            "description": "The CEILING or CEIL function is used to round a number up to the next whole number. (TheFLOOR functionrounds a number down to the next whole number.)",
            "syntax": "{CEIL(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "The number or expression that evaluates to a number. It can be the SMALLINT , INTEGER , BIGINT , DECIMAL , FLOAT4 , FLOAT8 , or SUPER type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "CEILING}",
            "description": "The CEILING or CEIL function is used to round a number up to the next whole number. (TheFLOOR functionrounds a number down to the next whole number.)",
            "syntax": "CEILING}(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "The number or expression that evaluates to a number. It can be the SMALLINT , INTEGER , BIGINT , DECIMAL , FLOAT4 , FLOAT8 , or SUPER type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "COS",
            "description": "COS is a trigonometric function that returns the cosine of a number.  The return value is in radians and is between-1and1, inclusive.",
            "syntax": "COS(double_precision)",
            "arguments": [
                {
                    "name": "number",
                    "description": "The input parameter is a DOUBLE PRECISION number.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "COT",
            "description": "COT is a trigonometric function that returns the cotangent of a number. The input parameter must be nonzero.",
            "syntax": "COT(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "The input parameter is a DOUBLE PRECISION number.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DEGREES",
            "description": "Converts an angle in radians to its equivalent in degrees.",
            "syntax": "DEGREES(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "The input parameter is a DOUBLE PRECISION number.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DEXP",
            "description": "The DEXP function returns the exponential value in scientific notation for a double precision number. The only difference between the DEXP and EXP functions is that the parameter for DEXP must be aDOUBLE PRECISION.",
            "syntax": "DEXP(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "The input parameter is a DOUBLE PRECISION number.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DLOG10",
            "description": "The DLOG10 returns the base 10 logarithm of the input parameter. Synonym ofLOG function.",
            "syntax": "DLOG10(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "The input parameter is a DOUBLE PRECISION number.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "EXP",
            "description": "The EXP function implements the exponential function for a numeric expression, or the base of the natural logarithm,e, raised to the power of expression. The EXP function is the inverse ofLN function.",
            "syntax": "EXP(expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The expression must be an INTEGER , DECIMAL , or DOUBLE PRECISION data type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "FLOOR",
            "description": "The FLOOR function rounds a number down to the next whole number.",
            "syntax": "FLOOR(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "The number or expression that evaluates to a number. It can be the SMALLINT , INTEGER , BIGINT , DECIMAL , FLOAT4 , FLOAT8 , or SUPER type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "LN",
            "description": "Returns the natural logarithm of the input parameter. Synonym ofDLOG1 function.",
            "syntax": "LN(expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The target column or expression that the function operates on. Note This function returns an error for some data types if the expression references an Amazon Redshift user-created table or an Amazon Redshift STL or STV system table. Expressions with the following data types produce an error if they reference a user-created or system table. Expressions with these data types run exclusively on the leader node: BOOLEAN CHAR DATE DECIMAL or NUMERIC TIMESTAMP VARCHAR Expressions with the following data types run successfully on user-created tables and STL or STV system tables: BIGINT DOUBLE PRECISION INTEGER REAL SMALLINT",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "LOG",
            "description": "Returns logarithm of a number. If you're using this function to calculate the base 10 logarithm, you can also useDLOG10 function.",
            "syntax": "LOG([base, ]argument)",
            "arguments": [
                {
                    "name": "base",
                    "description": "(Optional) The base of the logarithm function. This number must be positive and can't equal 1 . If this parameter is omitted, Amazon Redshift computes the base 10 logarithm of the argument .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "argument",
                    "description": "The argument of the logarithm function. This number must be positive. If the argument value is 1 , the function returns 0 .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "MOD",
            "description": "Returns the remainder of two numbers, otherwise known as amodulooperation. To calculate the result, the first parameter is divided by the second.",
            "syntax": "MOD(number1,number2)",
            "arguments": [
                {
                    "name": "number1",
                    "description": "The first input parameter is an INTEGER , SMALLINT , BIGINT , or DECIMAL number. If either parameter is a DECIMAL type, the other parameter must also be a DECIMAL type. If either parameter is an INTEGER , the other parameter can be an INTEGER , SMALLINT , or BIGINT . Both parameters can also be SMALLINT or BIGINT , but one parameter cannot be a SMALLINT if the other is a BIGINT .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "number2",
                    "description": "The second parameter is an INTEGER , SMALLINT , BIGINT , or DECIMAL number. The same data type rules apply to number2 as to number1 .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "PI",
            "description": "The PI function returns the value of pi to 14 decimal places.",
            "syntax": "PI()",
            "arguments": null
        },
        {
            "name": "{POW",
            "description": "The POWER function is an exponential function that raises a numeric expression to the power of a second numeric expression. For example, 2 to the third power is calculated asPOWER(2,3), with a result of8.",
            "syntax": "{POW(expression1,expression2)",
            "arguments": [
                {
                    "name": "expression1",
                    "description": "Numeric expression to be raised. Must be an INTEGER , DECIMAL , or FLOAT data type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "expression2",
                    "description": "Power to raise expression1 . Must be an INTEGER , DECIMAL , or FLOAT data type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "POWER}",
            "description": "The POWER function is an exponential function that raises a numeric expression to the power of a second numeric expression. For example, 2 to the third power is calculated asPOWER(2,3), with a result of8.",
            "syntax": "POWER}(expression1,expression2)",
            "arguments": [
                {
                    "name": "expression1",
                    "description": "Numeric expression to be raised. Must be an INTEGER , DECIMAL , or FLOAT data type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "expression2",
                    "description": "Power to raise expression1 . Must be an INTEGER , DECIMAL , or FLOAT data type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "RADIANS",
            "description": "The RADIANS function converts an angle in degrees to its equivalent in radians.",
            "syntax": "RADIANS(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "The input parameter is a DOUBLE PRECISION number.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "RANDOM",
            "description": "The RANDOM function generates a random value between 0.0 (inclusive) and 1.0 (exclusive).",
            "syntax": "RANDOM()",
            "arguments": null
        },
        {
            "name": "ROUND",
            "description": "The ROUND function rounds numbers to the nearest integer or decimal. The ROUND function can optionally include a second argument as anINTEGERto indicate the number of decimal places for rounding, in either direction. When you don't provide the second argument, the function rounds to the nearest whole number. When the second argumentintegeris specified, the function rounds to the nearest number withintegerdecimal places of precision.",
            "syntax": "ROUND(number[ ,integer] )",
            "arguments": [
                {
                    "name": "number",
                    "description": "A number or expression that evaluates to a number. It can be the DECIMAL , FLOAT8 or SUPER type. Amazon Redshift can implicitly convert other numeric data types.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "integer",
                    "description": "(Optional) An INTEGER that indicates the number of decimal places for rounding in either direction. The SUPER data type isn't supported for this argument.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SIN",
            "description": "SIN is a trigonometric function that returns the sine of a number. The return value is between-1and1.",
            "syntax": "SIN(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "A DOUBLE PRECISION number in radians.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SIGN",
            "description": "The SIGN function returns the sign (positive or negative) of a number. The result of the SIGN function is1if the argument is positive,-1if the argument is negative, or0if the argument is0.",
            "syntax": "SIGN(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "Number or expression that evaluates to a number. It can be a DECIMAL , FLOAT8 , or SUPER type. Amazon Redshift can convert other data types per the implicit conversion rules.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SQRT",
            "description": "The SQRT function returns the square root of aNUMERICvalue. The square root is a number multiplied by itself to get the given value.",
            "syntax": "SQRT(expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The expression must have an INTEGER , DECIMAL , or FLOAT data type, or a data type that implicitly converts to those data types. The expression can include functions.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TAN",
            "description": "TAN is a trigonometric function that returns the tangent of a number. The input argument is a number (in radians).",
            "syntax": "TAN(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "A DOUBLE PRECISION number.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TRUNC",
            "description": "The TRUNC function truncates numbers to the previous integer or decimal. The TRUNC function can optionally include a second argument as anINTEGERto indicate the number of decimal places for rounding, in either direction. When you don't provide the second argument, the function rounds to the nearest whole number. When the second argumentintegeris specified, the function rounds to the nearest number withintegerdecimal places of precision. This function can also truncate aTIMESTAMPand return aDATE. For more information, seeTRUNC function.",
            "syntax": "TRUNC(number[ ,integer])",
            "arguments": [
                {
                    "name": "number",
                    "description": "A number or an expression that evaluates to a number. It can be the DECIMAL , FLOAT8 or SUPER type. Amazon Redshift can convert other data types per the implicit conversion rules.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "integer",
                    "description": "(Optional) An INTEGER that indicates the number of decimal places of precision, in either direction. If no integer is provided, the number is truncated as a whole number; if an integer is specified, the number is truncated to the specified decimal place. This isn't supported for the SUPER data type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "LOWER_ATTRIBUTE_NAMES",
            "description": "Converts all applicable attribute names in a SUPER value to lowercase, using the same case conversion routine as theLOWER function. LOWER_ATTRIBUTE_NAMES supports UTF-8 multibyte characters, up to a maximum of four bytes per character. To convert SUPER attribute names to uppercase, use theUPPER_ATTRIBUTE_NAMES function.",
            "syntax": "LOWER_ATTRIBUTE_NAMES(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "OBJECT",
            "description": "Creates an object of the SUPER data type.",
            "syntax": "OBJECT([ key1, value1 ],[ key2, value2 ...])",
            "arguments": [
                {
                    "name": "key1, key2",
                    "description": "Expressions that evaluate to VARCHAR type strings.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "value1, value2",
                    "description": "Expressions of any Amazon Redshift data type except datetime types, since Amazon Redshift doesn't cast datetime types to the SUPER data type. For more information on datetime types, see Datetime types . value expressions in an object don't need to be of the same data type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "OBJECT_TRANSFORM",
            "description": "Transforms a SUPER object.",
            "syntax": "OBJECT_TRANSFORM(input[KEEPpath1, ...]",
            "arguments": [
                {
                    "name": "input",
                    "description": "An expression that resolves to a SUPER type object.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "KEEP",
                    "description": "All path values specified in this clause are kept and carried over to the output object. This clause is optional.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "path1,path2, ...",
                    "description": "Constant string literals, in the format of double-quoted path components delimited by periods. For example, '\"a\".\"b\".\"c\"' is a valid path value. This applies to the path parameter in both the KEEP and SET clauses.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "SET",
                    "description": "path and value pairs to modify an exiting path or add a new path, and set the value of that path in the output object. This clause is optional.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "value1,value2, ...",
                    "description": "Expressions that resolve to SUPER type values. Note that numeric, text, and Boolean types are resolvable to SUPER.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "[",
            "description": "Transforms a SUPER object.",
            "syntax": "[(S",
            "arguments": [
                {
                    "name": "input",
                    "description": "An expression that resolves to a SUPER type object.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "KEEP",
                    "description": "All path values specified in this clause are kept and carried over to the output object. This clause is optional.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "path1,path2, ...",
                    "description": "Constant string literals, in the format of double-quoted path components delimited by periods. For example, '\"a\".\"b\".\"c\"' is a valid path value. This applies to the path parameter in both the KEEP and SET clauses.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "SET",
                    "description": "path and value pairs to modify an exiting path or add a new path, and set the value of that path in the output object. This clause is optional.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "value1,value2, ...",
                    "description": "Expressions that resolve to SUPER type values. Note that numeric, text, and Boolean types are resolvable to SUPER.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": ".",
            "description": "Transforms a SUPER object.",
            "syntax": ".(.",
            "arguments": [
                {
                    "name": "input",
                    "description": "An expression that resolves to a SUPER type object.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "KEEP",
                    "description": "All path values specified in this clause are kept and carried over to the output object. This clause is optional.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "path1,path2, ...",
                    "description": "Constant string literals, in the format of double-quoted path components delimited by periods. For example, '\"a\".\"b\".\"c\"' is a valid path value. This applies to the path parameter in both the KEEP and SET clauses.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "SET",
                    "description": "path and value pairs to modify an exiting path or add a new path, and set the value of that path in the output object. This clause is optional.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "value1,value2, ...",
                    "description": "Expressions that resolve to SUPER type values. Note that numeric, text, and Boolean types are resolvable to SUPER.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "object_transform_function",
            "description": "Transforms a SUPER object.",
            "syntax": "OBJECT_TRANSFORM(input[KEEPpath1, ...]\n  [SETpath1,value1,\n    ...,  ...\n  ]\n)",
            "arguments": [
                {
                    "name": "input",
                    "description": "An expression that resolves to a SUPER type object.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "KEEP",
                    "description": "All path values specified in this clause are kept and carried over to the output object. This clause is optional.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "path1,path2, ...",
                    "description": "Constant string literals, in the format of double-quoted path components delimited by periods. For example, '\"a\".\"b\".\"c\"' is a valid path value. This applies to the path parameter in both the KEEP and SET clauses.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "SET",
                    "description": "path and value pairs to modify an exiting path or add a new path, and set the value of that path in the output object. This clause is optional.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "value1,value2, ...",
                    "description": "Expressions that resolve to SUPER type values. Note that numeric, text, and Boolean types are resolvable to SUPER.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "UPPER_ATTRIBUTE_NAMES",
            "description": "Converts all applicable attribute names in a SUPER value to uppercase, using the same case conversion routine as theUPPER function. UPPER_ATTRIBUTE_NAMES supports UTF-8 multibyte characters, up to a maximum of four bytes per character. To convert SUPER attribute names to lowercase, use theLOWER_ATTRIBUTE_NAMES function.",
            "syntax": "UPPER_ATTRIBUTE_NAMES(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "AddBBox",
            "description": "AddBBox returns a copy of the input geometry that supports encoding with a precomputed bounding box. For more information about support for bounding boxes, seeBounding box.",
            "syntax": "AddBBox(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DropBBox",
            "description": "DropBBox returns a copy of the input geometry that doesn't support encoding with a precomputed bounding box. For more information about support for bounding boxes, seeBounding box.",
            "syntax": "DropBBox(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "GeometryType",
            "description": "GeometryType returns the subtype of an input geometry as a string.",
            "syntax": "GeometryType(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "H3_FromLongLat",
            "description": "H3_FromLongLat returns the corresponding H3 cell ID from an input longitude, latitude, and resolution. For information about H3 indexing, seeH3.",
            "syntax": "H3_FromLongLat(longitude,lattitude,resolution)",
            "arguments": [
                {
                    "name": "longitude",
                    "description": "A value of data type DOUBLE PRECISION or an expression that evaluates to a DOUBLE PRECISION type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "latitude",
                    "description": "A value of data type DOUBLE PRECISION or an expression that evaluates to a DOUBLE PRECISION type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "resolution",
                    "description": "A value of data type INTEGER or an expression that evaluates to an INTEGER type. The value represents the resolution of the H3 grid system. The value must be an integer between 0\u201315, inclusive. With 0 being the coarsest and 15 being the finest.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "H3_FromPoint",
            "description": "H3_FromPoint returns the corresponding H3 cell ID from an input geometry point and resolution. For information about H3 indexing, seeH3.",
            "syntax": "H3_FromPoint(geom,resolution)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The geom must be a POINT .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "resolution",
                    "description": "A value of data type INTEGER or an expression that evaluates to an INTEGER type. The value represents the resolution of the H3 grid system. The value must be an integer between 0\u201315, inclusive. With 0 being the coarsest and 15 being the finest.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "H3_Polyfill",
            "description": "H3_Polyfill returns the corresponding H3 cell IDs that correspond to the hexagons and pentagons that are contained in the input polygon of the given resolution. For information about H3 indexing, seeH3.",
            "syntax": "H3_Polyfill(geom,resolution)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The geom must be a POLYGON .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "resolution",
                    "description": "A value of data type INTEGER or an expression that evaluates to an INTEGER type. The value represents the resolution of the H3 grid system. The value must be an integer between 0\u201315, inclusive. With 0 being the coarsest and 15 being the finest.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_AddPoint",
            "description": "ST_AddPoint returns a linestring geometry that is the same as the input geometry with a point added. If an index is provided, then the point is added at the index position. If the index is -1 or not provided, then the point is appended to the linestring. The index is zero-based. The spatial reference system identifier (SRID) of the result is the same as that of the input geometry. The dimension of the returned geometry is the same as that of thegeom1value. Ifgeom1andgeom2have different dimensions,geom2is projected to the dimension ofgeom1.",
            "syntax": "ST_AddPoint(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be LINESTRING .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be POINT . The point can be the empty point.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "index",
                    "description": "A value of data type INTEGER that represents the position of a zero-based index.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_AddPoint",
            "description": "ST_AddPoint returns a linestring geometry that is the same as the input geometry with a point added. If an index is provided, then the point is added at the index position. If the index is -1 or not provided, then the point is appended to the linestring. The index is zero-based. The spatial reference system identifier (SRID) of the result is the same as that of the input geometry. The dimension of the returned geometry is the same as that of thegeom1value. Ifgeom1andgeom2have different dimensions,geom2is projected to the dimension ofgeom1.",
            "syntax": "ST_AddPoint(geom1,geom2,index)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be LINESTRING .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be POINT . The point can be the empty point.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "index",
                    "description": "A value of data type INTEGER that represents the position of a zero-based index.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Angle",
            "description": "ST_Angle returns the angle in radians between points measured clockwise as follows: If three points are input, then the returned angle P1-P2-P3 is measured as if the angle was obtained by rotating from P1 to P3 around P2 clockwise. If four points are input, then the returned clockwise angle formed by the directed lines P1-P2 and P3-P4 is returned. If the input is a degenerate case (that is, P1 equals P2, or P3 equals P4), then null is returned. The return value is in radians and in the range [0, 2\u03c0). ST_Angle operates on 2D projections of the input geometries.",
            "syntax": "ST_Angle(geom1,geom2,geom3)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be POINT .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be POINT .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom3",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be POINT .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom4",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be POINT .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Angle",
            "description": "ST_Angle returns the angle in radians between points measured clockwise as follows: If three points are input, then the returned angle P1-P2-P3 is measured as if the angle was obtained by rotating from P1 to P3 around P2 clockwise. If four points are input, then the returned clockwise angle formed by the directed lines P1-P2 and P3-P4 is returned. If the input is a degenerate case (that is, P1 equals P2, or P3 equals P4), then null is returned. The return value is in radians and in the range [0, 2\u03c0). ST_Angle operates on 2D projections of the input geometries.",
            "syntax": "ST_Angle(geom1,geom2,geom3,geom4)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be POINT .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be POINT .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom3",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be POINT .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom4",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be POINT .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Area",
            "description": "For an input geometry, ST_Area returns the Cartesian area of the 2D projection. The area units are the same as the units in which the coordinates of the input geometry are expressed. For points, linestrings, multipoints, and multilinestrings, the function returns 0. For geometry collections, it returns the sum of the areas of the geometries in the collection. For an input geography, ST_Area returns the geodesic area of the 2D projection of an input areal geography computed on the spheroid determined by the SRID. The unit of length is in square meters. The function returns zero (0) for points, multipoints, and linear geographies. When the input is a geometry collection, the function returns the sum of the areas of the areal geographies in the collection.",
            "syntax": "ST_Area(geo)",
            "arguments": [
                {
                    "name": "geo",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY , or an expression that evaluates to a GEOMETRY or GEOGRAPHY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_AsBinary",
            "description": "ST_AsBinary returns the hexadecimal well-known binary (WKB) representation of an input geometry. For 3DZ, 3DM, and 4D geometries, ST_AsBinary uses the Open Geospatial Consortium (OGC) standard value for the geometry type.",
            "syntax": "ST_AsBinary(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_AsEWKB",
            "description": "ST_AsEWKB returns the extended well-known binary (EWKB) representation of an input geometry. For 3DZ, 3DM, and 4D geometries, ST_AsEWKB uses the Open Geospatial Consortium (OGC) standard value for the geometry type.",
            "syntax": "ST_AsEWKB(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_AsEWKT",
            "description": "ST_AsEWKT returns the extended well-known text (EWKT) representation of an input geometry or geography. For 3DZ, 3DM, and 4D geometries, ST_AsEWKT appends Z, M, or ZM to the WKT value for the geometry type.",
            "syntax": "ST_AsEWKT(geo)",
            "arguments": [
                {
                    "name": "geo",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY , or an expression that evaluates to a GEOMETRY or GEOGRAPHY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "precision",
                    "description": "A value of data type INTEGER . For geometries, the coordinates of geo are displayed using the specified precision 1\u201320. If precision is not specified, the default is 15. For geographies, the coordinates of geo are displayed using the specified precision. If precision is not specified, the default is 15.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_AsEWKT",
            "description": "ST_AsEWKT returns the extended well-known text (EWKT) representation of an input geometry or geography. For 3DZ, 3DM, and 4D geometries, ST_AsEWKT appends Z, M, or ZM to the WKT value for the geometry type.",
            "syntax": "ST_AsEWKT(geo,precision)",
            "arguments": [
                {
                    "name": "geo",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY , or an expression that evaluates to a GEOMETRY or GEOGRAPHY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "precision",
                    "description": "A value of data type INTEGER . For geometries, the coordinates of geo are displayed using the specified precision 1\u201320. If precision is not specified, the default is 15. For geographies, the coordinates of geo are displayed using the specified precision. If precision is not specified, the default is 15.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_AsGeoJSON",
            "description": "ST_AsGeoJSON returns the GeoJSON representation of an input geometry or geography. For more information about GeoJSON, seeGeoJSONin Wikipedia. For 3DZ and 4D geometries, the output geometry is a 3DZ projection of the input 3DZ or 4D geometry. That is, thex,y, andzcoordinates are present in the output. For 3DM geometries, the output geometry is a 2D projection of the input 3DM geometry. That is, onlyxandycoordinates are present in the output. For input geographies, ST_AsGeoJSON returns the GeoJSON representation of an input geography. The coordinates of the geography are displayed using the specified precision.",
            "syntax": "ST_AsGeoJSON(geo)",
            "arguments": [
                {
                    "name": "geo",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY , or an expression that evaluates to a GEOMETRY or GEOGRAPHY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "precision",
                    "description": "A value of data type INTEGER . For geometries, the coordinates of geo are displayed using the specified precision 1\u201320. If precision is not specified, the default is 15. For geographies, the coordinates of geo are displayed using the specified precision. If precision is not specified, the default is 15.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_AsGeoJSON",
            "description": "ST_AsGeoJSON returns the GeoJSON representation of an input geometry or geography. For more information about GeoJSON, seeGeoJSONin Wikipedia. For 3DZ and 4D geometries, the output geometry is a 3DZ projection of the input 3DZ or 4D geometry. That is, thex,y, andzcoordinates are present in the output. For 3DM geometries, the output geometry is a 2D projection of the input 3DM geometry. That is, onlyxandycoordinates are present in the output. For input geographies, ST_AsGeoJSON returns the GeoJSON representation of an input geography. The coordinates of the geography are displayed using the specified precision.",
            "syntax": "ST_AsGeoJSON(geo,precision)",
            "arguments": [
                {
                    "name": "geo",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY , or an expression that evaluates to a GEOMETRY or GEOGRAPHY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "precision",
                    "description": "A value of data type INTEGER . For geometries, the coordinates of geo are displayed using the specified precision 1\u201320. If precision is not specified, the default is 15. For geographies, the coordinates of geo are displayed using the specified precision. If precision is not specified, the default is 15.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_AsHexWKB",
            "description": "ST_AsHexWKB returns the hexadecimal well-known binary (WKB) representation of an input geometry or geography using ASCII hexadecimal characters (0\u20139, A\u2013F). For 3DZ, 3DM, and 4D geometries or geographies, ST_AsHexWKB uses the Open Geospatial Consortium (OGC) standard value for the geometry or geography type.",
            "syntax": "ST_AsHexWKB(geo)",
            "arguments": [
                {
                    "name": "geo",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY , or an expression that evaluates to a GEOMETRY or GEOGRAPHY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_AsHexEWKB",
            "description": "ST_AsHexEWKB returns the extended well-known binary (EWKB) representation of an input geometry or geography using ASCII hexadecimal characters (0\u20139, A\u2013F). For 3DZ, 3DM, and 4D geometries or geographies, ST_AsHexEWKB uses the PostGIS extended WKB value for the geometry or geography type.",
            "syntax": "ST_AsHexEWKB(geo)",
            "arguments": [
                {
                    "name": "geo",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY , or an expression that evaluates to a GEOMETRY or GEOGRAPHY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_AsText",
            "description": "ST_AsText returns the well-known text (WKT) representation of an input geometry or geography. For 3DZ, 3DM, and 4D geometries or geographies, ST_AsEWKT appends Z, M, or ZM to the WKT value for the geometry or geography type.",
            "syntax": "ST_AsText(geo)",
            "arguments": [
                {
                    "name": "geo",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY , or an expression that evaluates to a GEOMETRY or GEOGRAPHY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "precision",
                    "description": "A value of data type INTEGER . For geometries, the coordinates of geo are displayed using the specified precision 1\u201320. If precision is not specified, the default is 15. For geogpraphies, the coordinates of geo are displayed using the specified precision. If precision is not specified, the default is 15.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_AsText",
            "description": "ST_AsText returns the well-known text (WKT) representation of an input geometry or geography. For 3DZ, 3DM, and 4D geometries or geographies, ST_AsEWKT appends Z, M, or ZM to the WKT value for the geometry or geography type.",
            "syntax": "ST_AsText(geo,precision)",
            "arguments": [
                {
                    "name": "geo",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY , or an expression that evaluates to a GEOMETRY or GEOGRAPHY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "precision",
                    "description": "A value of data type INTEGER . For geometries, the coordinates of geo are displayed using the specified precision 1\u201320. If precision is not specified, the default is 15. For geogpraphies, the coordinates of geo are displayed using the specified precision. If precision is not specified, the default is 15.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Azimuth",
            "description": "ST_Azimuth returns the north-based Cartesian azimuth using the 2D projections of the two input points.",
            "syntax": "ST_Azimuth(point1,point2)",
            "arguments": [
                {
                    "name": "point1",
                    "description": "A POINT value of data type GEOMETRY . The spatial reference system identifier (SRID) of point1 must match the SRID of point2 .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "point2",
                    "description": "A POINT value of data type GEOMETRY . The SRID of point2 must match the SRID of point1 .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Boundary",
            "description": "ST_Boundary returns the boundary of an input geometry as follows: If the input geometry is empty (that is, it contains no points) it is returned as is. If the input geometry is a point or nonempty multipoint, an empty geometry collection is returned. If the input is a linestring or a multilinestring, then a multipoint containing all the points on the boundary is returned. The multipoint might be empty). If the input is a polygon that does not have any interior rings, then a closed linestring representing its boundary is returned. If the input is a polygon that has interior rings, or is a multipolygon, then a multilinestring is returned. The multilinestring contains all the boundaries of all the rings in the areal geometry as closed linestrings. To determine point equality, ST_Boundary operates on the 2D projection of the input geometry. If the input geometry is empty, a copy of it is returned in the same dimension as the input. For nonempty 3DM and 4D geometries, theirmcoordinates are dropped. In the special case of 3DZ and 4D multilinestrings, thezcoordinates of the multilinestring's boundary points are computed as the averages of the distinct z-values of the linestring boundary points with the same 2D projection.",
            "syntax": "ST_Boundary(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Buffer",
            "description": "ST_Buffer returns 2D geometry that represents all points whose distance from the input geometry projected on the xy-Cartesian plane is less than or equal to the input distance.",
            "syntax": "ST_Buffer(geom,distance)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "distance",
                    "description": "A value of data type DOUBLE PRECISION that represents distance (or radius) of the buffer.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "number_of_segments_per_quarter_circle",
                    "description": "A value of data type INTEGER . This value determines the number of points to approximate a quarter circle around each vertex of the input geometry. Negative values default to zero. The default is 8.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Buffer",
            "description": "ST_Buffer returns 2D geometry that represents all points whose distance from the input geometry projected on the xy-Cartesian plane is less than or equal to the input distance.",
            "syntax": "ST_Buffer(geom,distance,number_of_segments_per_quarter_circle)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "distance",
                    "description": "A value of data type DOUBLE PRECISION that represents distance (or radius) of the buffer.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "number_of_segments_per_quarter_circle",
                    "description": "A value of data type INTEGER . This value determines the number of points to approximate a quarter circle around each vertex of the input geometry. Negative values default to zero. The default is 8.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Centroid",
            "description": "ST_Centroid returns a point that represents a centroid of a geometry as follows: ForPOINTgeometries, it returns the point whose coordinates are the average of the coordinates of the points in the geometry. ForLINESTRINGgeometries, it returns the point whose coordinates are the weighted average of the midpoints of the segments of the geometry, where the weights are the lengths of the segments of the geometry. ForPOLYGONgeometries, it returns the point whose coordinates are the weighted average of the centroids of a triangulation of the areal geometry where the weights are the areas of the triangles in the triangulation. For geometry collections, it returns the weighted average of the centroids of the geometries of maximum topological dimension in the geometry collection.",
            "syntax": "ST_Centroid(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Collect",
            "description": "ST_Collect has two variants. One accepts two geometries, and one accepts an aggregate expression. The first variant of ST_Collect creates a geometry from the input geometries. The order of the input geometries is preserved. This variant works as follows: If both input geometries are points, then aMULTIPOINTwith two points is returned. If both input geometries are linestrings, then aMULTILINESTRINGwith two linestrings is returned. If both input geometries are polygons, then aMULTIPOLYGONwith two polygons is returned. Otherwise, aGEOMETRYCOLLECTIONwith two input geometries is returned. The second variant of ST_Collect creates a geometry from geometries in a geometry column. There isn't a determined return order of the geometries. Specify the WITHIN GROUP (ORDER BY ...)  clause to specify the order of the returned geometries. This variant works as follows: If all non-NULL rows in the input aggregate expression are points, then a multipoint containing all the points in the aggregate expression is returned. If all non-NULL rows in the aggregate expression are linestrings, then a multilinestring containing all the linestrings in the aggregate expression is returned. If all non-NULL rows in the aggregate expression are polygons, the result is a multipolygon containing all the polygons in the aggregate expression is returned. Otherwise, aGEOMETRYCOLLECTIONcontaining all the geometries in the aggregate expression is returned. The ST_Collect returns the geometry of the same dimension as the input geometries. All input geometries must be of the same dimension.",
            "syntax": "ST_Collect(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "aggregate_expression",
                    "description": "A column of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "[WITHIN GROUP (ORDER BYsort_expression1[ASC | DESC] [,sort_expression2[ASC | DESC] ...])]",
                    "description": "An optional clause that specifies the sort order of the aggregated values. The ORDER BY clause contains a list of sort expressions. Sort expressions are expressions similar to valid sort expressions in a query select list, such as a column name. You can specify ascending ( ASC ) or descending ( DESC ) order. The default is ASC .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Collect",
            "description": "ST_Collect has two variants. One accepts two geometries, and one accepts an aggregate expression. The first variant of ST_Collect creates a geometry from the input geometries. The order of the input geometries is preserved. This variant works as follows: If both input geometries are points, then aMULTIPOINTwith two points is returned. If both input geometries are linestrings, then aMULTILINESTRINGwith two linestrings is returned. If both input geometries are polygons, then aMULTIPOLYGONwith two polygons is returned. Otherwise, aGEOMETRYCOLLECTIONwith two input geometries is returned. The second variant of ST_Collect creates a geometry from geometries in a geometry column. There isn't a determined return order of the geometries. Specify the WITHIN GROUP (ORDER BY ...)  clause to specify the order of the returned geometries. This variant works as follows: If all non-NULL rows in the input aggregate expression are points, then a multipoint containing all the points in the aggregate expression is returned. If all non-NULL rows in the aggregate expression are linestrings, then a multilinestring containing all the linestrings in the aggregate expression is returned. If all non-NULL rows in the aggregate expression are polygons, the result is a multipolygon containing all the polygons in the aggregate expression is returned. Otherwise, aGEOMETRYCOLLECTIONcontaining all the geometries in the aggregate expression is returned. The ST_Collect returns the geometry of the same dimension as the input geometries. All input geometries must be of the same dimension.",
            "syntax": "ST_Collect(aggregate_expression)  [WITHIN GROUP ",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "aggregate_expression",
                    "description": "A column of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "[WITHIN GROUP (ORDER BYsort_expression1[ASC | DESC] [,sort_expression2[ASC | DESC] ...])]",
                    "description": "An optional clause that specifies the sort order of the aggregated values. The ORDER BY clause contains a list of sort expressions. Sort expressions are expressions similar to valid sort expressions in a query select list, such as a column name. You can specify ascending ( ASC ) or descending ( DESC ) order. The default is ASC .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Contains",
            "description": "ST_Contains returns true if the 2D projection of the first input geometry contains the 2D projection of the second input geometry. GeometryAcontains geometryBif every point inBis a point inA, and their interiors have nonempty intersection. ST_Contains(A,B) is equivalent to ST_Within(B,A).",
            "syntax": "ST_Contains(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. This value is compared with geom1 to determine if it is contained within geom1 .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_ContainsProperly",
            "description": "ST_ContainsProperly returns true if both input geometries are nonempty, and all points of the 2D projection of the second geometry are interior points of the 2D projection of the first geometry.",
            "syntax": "ST_ContainsProperly(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype can't be GEOMETRYCOLLECTION .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype can't be GEOMETRYCOLLECTION . This value is compared with geom1 to determine if all its points are interior points of geom1 .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_ConvexHull",
            "description": "ST_ConvexHull returns a geometry that represents the convex hull of the nonempty points contained in the input geometry. For empty input, the resulting geometry is the same as the input geometry. For all nonempty input, the function operates on the 2D projection of the input geometry. However, the dimension of the output geometry depends on the dimension of the input geometry. More specifically, when the input geometry is a nonempty 3DM or 3D geometry,mcoordinates are dropped. That is, the dimension of the returned geometry is 2D or 3DZ, respectively. If the input is a nonempty 2D or 3DZ geometry, the resulting geometry has the same dimension.",
            "syntax": "ST_ConvexHull(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_CoveredBy",
            "description": "ST_CoveredBy returns true if the 2D projection of the first input geometry is covered by the 2D projection of the second input geometry. GeometryAis covered by geometryBif both are nonempty and every point inAis a point inB. ST_CoveredBy(A,B) is equivalent to ST_Covers(B,A).",
            "syntax": "ST_CoveredBy(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. This value is compared with geom2 to determine if it's covered by geom2 .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Covers",
            "description": "ST_Covers returns true if the 2D projection of the first input geometry covers the 2D projection of the second input geometry. GeometryAcovers geometryBif both are nonempty and every point inBis a point inA. ST_Covers(A,B) is equivalent to ST_CoveredBy(B,A).",
            "syntax": "ST_Covers(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. This value is compared with geom1 to determine if it covers geom1 .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Crosses",
            "description": "ST_Crosses returns true if the 2D projections of the two input geometries cross each other.",
            "syntax": "ST_Crosses(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Dimension",
            "description": "ST_Dimension returns the inherent dimension of an input geometry. Theinherent dimensionis the dimension value of the subtype that is defined in the geometry. For 3DM, 3DZ, and 4D geometry inputs, ST_Dimension returns the same result as for 2D geometry inputs.",
            "syntax": "ST_Dimension(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Disjoint",
            "description": "ST_Disjoint returns true if the 2D projections of the two input geometries have no points in common.",
            "syntax": "ST_Disjoint(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Distance",
            "description": "For input geometries, ST_Distance returns the minimum Euclidean distance between the 2D projections of the two input geometry values. For 3DM, 3DZ, 4D geometries, ST_Distance returns the Euclidean distance between the 2D projections of two input geometry values. For input geographies, ST_Distance returns the geodesic distance of the two 2D points. The unit of distance is in meters. For geographies other than points and empty points an error is returned.",
            "syntax": "ST_Distance(geo1,geo2)",
            "arguments": [
                {
                    "name": "geo1",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY , or an expression that evaluates to a GEOMETRY or GEOGRAPHY type. The data type of geo1 must be the same as geo2 .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geo2",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY , or an expression that evaluates to a GEOMETRY or GEOGRAPHY type. The data type of geo2 must be the same as geo1 .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_DistanceSphere",
            "description": "ST_DistanceSphere returns the distance between two point geometries lying on a sphere.",
            "syntax": "ST_DistanceSphere(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A point value in degrees of data type GEOMETRY lying on a sphere. The first coordinate of the point is the longitude value. The second coordinate of the point is the latitude value. For 3DZ, 3DM, or 4D geometries, only the first two coordinates are used.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A point value in degrees of data type GEOMETRY lying on a sphere. The first coordinate of the point is the longitude value. The second coordinate of the point is the latitude value. For 3DZ, 3DM, or 4D geometries, only the first two coordinates are used.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "radius",
                    "description": "The radius of a sphere of data type DOUBLE PRECISION . If no radius is provided, the sphere defaults to Earth and the radius is computed from the World Geodetic System (WGS) 84 representation of the ellipsoid.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_DistanceSphere",
            "description": "ST_DistanceSphere returns the distance between two point geometries lying on a sphere.",
            "syntax": "ST_DistanceSphere(geom1,geom2,radius)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A point value in degrees of data type GEOMETRY lying on a sphere. The first coordinate of the point is the longitude value. The second coordinate of the point is the latitude value. For 3DZ, 3DM, or 4D geometries, only the first two coordinates are used.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A point value in degrees of data type GEOMETRY lying on a sphere. The first coordinate of the point is the longitude value. The second coordinate of the point is the latitude value. For 3DZ, 3DM, or 4D geometries, only the first two coordinates are used.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "radius",
                    "description": "The radius of a sphere of data type DOUBLE PRECISION . If no radius is provided, the sphere defaults to Earth and the radius is computed from the World Geodetic System (WGS) 84 representation of the ellipsoid.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_DWithin",
            "description": "ST_DWithin returns true if the Euclidean distance between the 2D projections of the two input geometry values is not larger than a threshold value.",
            "syntax": "ST_DWithin(geom1,geom2,threshold)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "threshold",
                    "description": "A value of data type DOUBLE PRECISION . This value is in the units of the input arguments.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_EndPoint",
            "description": "ST_EndPoint returns the last point of an input linestring. The spatial reference system identifier (SRID) value of the result is the same as that of the input geometry. The dimension of the returned geometry is the same as that of the input geometry.",
            "syntax": "ST_EndPoint(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be LINESTRING .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Envelope",
            "description": "ST_Envelope returns the minimum bounding box of the input geometry, as follows: If the input geometry is empty, the returned geometry is a copy of the input geometry. If the minimum bounding box of the input geometry degenerates to a point, the returned geometry is a point. If the minimum bounding box of the input geometry is one-dimensional, a two-point linestring is returned. If none of the preceding is true, the function returns a clockwise-oriented polygon whose vertices are the corners of the minimum bounding box. The spatial reference system identifier (SRID) of the returned geometry is the same as that of the input geometry. For all nonempty input, the function operates on the 2D projection of the input geometry.",
            "syntax": "ST_Envelope(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Equals",
            "description": "ST_Equals returns true if the 2D projections of the input geometries are geometrically equal. Geometries are considered geometrically equal if they have equal point sets and their interiors have a nonempty intersection.",
            "syntax": "ST_Equals(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. This value is compared with geom1 to determine if it is equal to geom1 .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_ExteriorRing",
            "description": "ST_ExteriorRing returns a closed linestring that represents the exterior ring of an input polygon. The dimension of the returned geometry is the same as that of the input geometry.",
            "syntax": "ST_ExteriorRing(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Force2D",
            "description": "ST_Force2D returns a 2D geometry of the input geometry. For 2D geometries, a copy of the input is returned. For 3DZ, 3DM, and 4D geometries, ST_Force2D projects the geometry to the xy-Cartesian plane. Empty points in the input geometry remain empty points in the output geometry.",
            "syntax": "ST_Force2D(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Force3DM",
            "description": "ST_Force3DM returns a 3DM geometry of the input geometry. For 2D geometries, themcoordinates of the nonempty points in the output geometry are all set to0. For 3DM geometries, a copy of the input geometry is returned. For 3DZ geometries, the geometry is projected to the xy-Cartesian plane, and themcoordinates of the nonempty points in the output geometry are all set to0. For 4D geometries, the geometry is projected to the xym-Cartesian space. Empty points in the input geometry remain empty points in the output geometry.",
            "syntax": "ST_Force3DM(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Force3DZ",
            "description": "ST_Force3DZ returns a 3DZ geometry from the input geometry. For 2D geometries, thezcoordinates of the nonempty points in the output geometry are all set to0. For 3DM geometries, the geometry is projected on the xy-Cartesian plane, and thezcoordinates of the nonempty points in the output geometry are all set to0. For 3DZ geometries, a copy of the input geometry is returned. For 4D geometries, the geometry is projected to the xyz-Cartesian space. Empty points in the input geometry remain empty points in the output geometry.",
            "syntax": "ST_Force3DZ(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Force4D",
            "description": "ST_Force4D returns a 4D geometry of the input geometry. For 2D geometries, thezandmcoordinates of the nonempty points in the output geometry are all set to0. For 3DM geometries, thezcoordinates of the nonempty points in the output geometry are all set to0. For 3DZ geometries, themcoordinates of the nonempty points in the output geometry are all set to0. For 4D geometries, a copy of the input geometry is returned. Empty points in the input geometry remain empty points in the output geometry.",
            "syntax": "ST_Force4D(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeoHash",
            "description": "ST_GeoHash returns thegeohashrepresentation of the input point with the specified precision. The default precision value is 20. For more information about the definition of geohash, seeGeohashin Wikipedia.",
            "syntax": "ST_GeoHash(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "precision",
                    "description": "A value of data type INTEGER . The default is 20.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeoHash",
            "description": "ST_GeoHash returns thegeohashrepresentation of the input point with the specified precision. The default precision value is 20. For more information about the definition of geohash, seeGeohashin Wikipedia.",
            "syntax": "ST_GeoHash(geom,precision)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "precision",
                    "description": "A value of data type INTEGER . The default is 20.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeogFromText",
            "description": "ST_GeogFromText constructs a geography object from a well-known text (WKT) or extended well-known text (EWKT) representation of an input geography.",
            "syntax": "ST_GeogFromText(wkt_string)",
            "arguments": [
                {
                    "name": "wkt_string",
                    "description": "A value of data type VARCHAR that is a WKT or EWKT representation of a geography.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeogFromWKB",
            "description": "ST_GeogFromWKB constructs a geography object from a hexadecimal well-known binary (WKB) representation of an input geography.",
            "syntax": "ST_GeogFromWKB(wkb_string)",
            "arguments": [
                {
                    "name": "wkb_string",
                    "description": "A value of data type VARCHAR that is a hexadecimal WKB representation of a geography.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeometryN",
            "description": "ST_GeometryN returns a geometry pointed to by the input index of the input geometry, as follows: If the input is a point, linestring, or polygon, then a geometry is returned as is if the index is equal to one (1), and null if the index is other than one (1). If the input is a multipoint, multilinestring, multipolygon, or geometry collection, then a point, linestring, polygon, or geometry collection is returned as pointed to by an input index. The index is one-based. The spatial reference system identifier (SRID) of the result is the same as that of the input geometry. The dimension of the returned geometry is the same as that of the input geometry.",
            "syntax": "ST_GeometryN(geom,index)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "index",
                    "description": "A value of data type INTEGER that represents the position of a one-based index.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeometryType",
            "description": "ST_GeometryType returns the subtype of an input geometry as a string. For 3DM, 3DZ, and 4D geometry inputs, ST_GeometryType returns the same result as for 2D geometry inputs.",
            "syntax": "ST_GeometryType(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeomFromEWKB",
            "description": "ST_GeomFromEWKB constructs a geometry object from the extended well-known binary (EWKB) representation of an input geometry. ST_GeomFromEWKB accepts 3DZ, 3DM, and 4D geometries written in WKB and EWKB hexadecimal format.",
            "syntax": "ST_GeomFromEWKB(ewkb_string)",
            "arguments": [
                {
                    "name": "ewkb_string",
                    "description": "A value of data type VARCHAR that is a hexadecimal EWKB representation of a geometry.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeomFromEWKT",
            "description": "ST_GeomFromEWKT constructs a geometry object from the extended well-known text (EWKT) representation of an input geometry. ST_GeomFromEWKT accepts 3DZ, 3DM, and 4D where the geometry type is prefixed with Z, M, or ZM, respectively.",
            "syntax": "ST_GeomFromEWKT(ewkt_string)",
            "arguments": [
                {
                    "name": "ewkt_string",
                    "description": "A value of data type VARCHAR or an expression that evaluates to a VARCHAR type, that is an EWKT representation of a geometry. You can use the WKT keyword EMPTY to designate an empty point, a multipoint with an empty point, or a geometry collection with an empty point. The following example creates an empty point. ST_GeomFromEWKT('SRID=4326;POINT EMPTY');",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeomFromGeoHash",
            "description": "ST_GeomFromGeoHash constructs a geometry object from the geohash representation of an input geometry. ST_GeomFromGeoHash returns a two-dimensional (2D) geometry with the spatial reference identifier (SRID) of zero (0). For more information about the geohash format, seeGeohashin Wikipedia.",
            "syntax": "ST_GeomFromGeoHash(geohash_string)",
            "arguments": [
                {
                    "name": "geohash_string",
                    "description": "A value of data type VARCHAR or an expression that evaluates to a VARCHAR type, that is a geohash representation of a geometry.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "precision",
                    "description": "A value of data type INTEGER that represents the precision of the geohash. The value is the number of characters of the geohash to be used as precision. If the value is not specified, less than zero, or greater than the geohash_string length. then the geohash_string length is used.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeomFromGeoHash",
            "description": "ST_GeomFromGeoHash constructs a geometry object from the geohash representation of an input geometry. ST_GeomFromGeoHash returns a two-dimensional (2D) geometry with the spatial reference identifier (SRID) of zero (0). For more information about the geohash format, seeGeohashin Wikipedia.",
            "syntax": "ST_GeomFromGeoHash(geohash_string,precision)",
            "arguments": [
                {
                    "name": "geohash_string",
                    "description": "A value of data type VARCHAR or an expression that evaluates to a VARCHAR type, that is a geohash representation of a geometry.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "precision",
                    "description": "A value of data type INTEGER that represents the precision of the geohash. The value is the number of characters of the geohash to be used as precision. If the value is not specified, less than zero, or greater than the geohash_string length. then the geohash_string length is used.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeomFromGeoJSON",
            "description": "ST_GeomFromGeoJSON constructs a geometry object from the GeoJSON representation of an input geometry. For more information about the GeoJSON format, seeGeoJSONin Wikipedia. If there is at least one point with three or more coordinates, the resulting geometry is 3DZ, where the Z component is zero for the points that have only two coordinates. If all points in the input GeoJSON contain two coordinates or are empty, ST_GeomFromGeoJSON returns a 2D geometry. The returned geometry always has the spatial reference identifier (SRID) of 4326.",
            "syntax": "ST_GeomFromGeoJSON(geojson_string)",
            "arguments": [
                {
                    "name": "geojson_string",
                    "description": "A value of data type VARCHAR or an expression that evaluates to a VARCHAR type, that is a GeoJSON representation of a geometry.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeomFromGeoSquare",
            "description": "ST_GeomFromGeoSquare returns a geometry that covers the area that is represented by an input geosquare value. The returned geometry is always two-dimensional. To calculate a geosquare value, seeST_GeoSquare.",
            "syntax": "ST_GeomFromGeoSquare(geosquare)",
            "arguments": [
                {
                    "name": "geosquare",
                    "description": "A value of data type BIGINT or an expression that evaluates to a BIGINT type that is a geosquare value that describes the sequence of subdivisions made on the initial domain to reach the desired square. This value is calculated by ST_GeoSquare .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "max_depth",
                    "description": "A value of data type INTEGER that represents the maximum number of domain subdivisions made on the initial domain. The value must be greater than or equal to 1 .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeomFromGeoSquare",
            "description": "ST_GeomFromGeoSquare returns a geometry that covers the area that is represented by an input geosquare value. The returned geometry is always two-dimensional. To calculate a geosquare value, seeST_GeoSquare.",
            "syntax": "ST_GeomFromGeoSquare(geosquare,max_depth)",
            "arguments": [
                {
                    "name": "geosquare",
                    "description": "A value of data type BIGINT or an expression that evaluates to a BIGINT type that is a geosquare value that describes the sequence of subdivisions made on the initial domain to reach the desired square. This value is calculated by ST_GeoSquare .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "max_depth",
                    "description": "A value of data type INTEGER that represents the maximum number of domain subdivisions made on the initial domain. The value must be greater than or equal to 1 .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeomFromText",
            "description": "ST_GeomFromText constructs a geometry object from a well-known text (WKT) representation of an input geometry. ST_GeomFromText accepts 3DZ, 3DM, and 4D where the geometry type is prefixed with Z, M, or ZM, respectively.",
            "syntax": "ST_GeomFromText(wkt_string)",
            "arguments": [
                {
                    "name": "wkt_string",
                    "description": "A value of data type VARCHAR that is a WKT representation of a geometry. You can use the WKT keyword EMPTY to designate an empty point, a multipoint with an empty point, or a geometry collection with an empty point. The following example creates a multipoint with one empty and one nonempty point. ST_GeomFromEWKT('MULTIPOINT(1 0,EMPTY)');",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "srid",
                    "description": "A value of data type INTEGER that is a spatial reference identifier (SRID). If an SRID value is provided, the returned geometry has this SRID value. Otherwise, the SRID value of the returned geometry is set to zero (0).",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeomFromText",
            "description": "ST_GeomFromText constructs a geometry object from a well-known text (WKT) representation of an input geometry. ST_GeomFromText accepts 3DZ, 3DM, and 4D where the geometry type is prefixed with Z, M, or ZM, respectively.",
            "syntax": "ST_GeomFromText(wkt_string,srid)",
            "arguments": [
                {
                    "name": "wkt_string",
                    "description": "A value of data type VARCHAR that is a WKT representation of a geometry. You can use the WKT keyword EMPTY to designate an empty point, a multipoint with an empty point, or a geometry collection with an empty point. The following example creates a multipoint with one empty and one nonempty point. ST_GeomFromEWKT('MULTIPOINT(1 0,EMPTY)');",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "srid",
                    "description": "A value of data type INTEGER that is a spatial reference identifier (SRID). If an SRID value is provided, the returned geometry has this SRID value. Otherwise, the SRID value of the returned geometry is set to zero (0).",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeomFromWKB",
            "description": "ST_GeomFromWKB constructs a geometry object from a hexadecimal well-known binary (WKB) representation of an input geometry. ST_GeomFromWKB accepts 3DZ, 3DM, and 4D geometries written in WKB hexadecimal format.",
            "syntax": "ST_GeomFromWKB(wkb_string)",
            "arguments": [
                {
                    "name": "wkb_string",
                    "description": "A value of data type VARCHAR that is a hexadecimal WKB representation of a geometry.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "srid",
                    "description": "A value of data type INTEGER that is a spatial reference identifier (SRID). If an SRID value is provided, the returned geometry has this SRID value. Otherwise, the SRID value of the returned geometry is set to 0.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeomFromWKB",
            "description": "ST_GeomFromWKB constructs a geometry object from a hexadecimal well-known binary (WKB) representation of an input geometry. ST_GeomFromWKB accepts 3DZ, 3DM, and 4D geometries written in WKB hexadecimal format.",
            "syntax": "ST_GeomFromWKB(wkb_string,srid)",
            "arguments": [
                {
                    "name": "wkb_string",
                    "description": "A value of data type VARCHAR that is a hexadecimal WKB representation of a geometry.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "srid",
                    "description": "A value of data type INTEGER that is a spatial reference identifier (SRID). If an SRID value is provided, the returned geometry has this SRID value. Otherwise, the SRID value of the returned geometry is set to 0.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeoSquare",
            "description": "ST_GeoSquare recursively subdivides the domain ([-180, 180], [-90, 90]) into equal square regions calledgeosquaresto a specified depth. The subdivision is based on the location of a provided point. One of the geosquares containing the point is subdivided at each step until reaching the maximum depth. The selection of this geosquare is stable, that is, the function result depends on the input arguments only. The function returns a unique value that identifies the final geosquare in which the point is located. The ST_GeoSquare accepts a POINT where the x coordinate is representing the longitude, and the y coordinate is representing the latitude. The longitude and latitude are limited to [-180, 180] and [-90, 90], respectively. The output of ST_GeoSquare can be used as input to theST_GeomFromGeoSquarefunction. There are 360\u00b0 around the arc of the equatorial circumference of the Earth that are divided into two hemispheres (Eastern and Western), each with 180\u00b0 of longitudinal lines (Meridians) from the 0\u00b0 Meridian. By convention, the eastern longitudes are \"+\" (positive) coordinates when projected to an x-axis on a Cartesian plane and the western longitudes are \"-\" (negative) coordinates when projected to an x-axis on a Cartesian plane. There are 90\u00b0 of latitudinal lines north and south of the 0\u00b0 equatorial circumference of the Earth, each parallel to the 0\u00b0 equatorial circumference of the Earth. By convention, the northern latitudinal lines intersect the \"+\" (positive) y-axis when projected to a Cartesian plane, and the southern latitudinal lines intersect the \"-\" (negative) y-axis when projected to a Cartesian plane. The spherical grid formed by the intersection of longitudinal lines and latitudinal lines is converted to a grid projected onto a Cartesian plane with standard positive and negative x-coordinates and positive and negative y-coordinates on the Cartesian plane. The purpose of ST_GeoSquare is to tag or mark close points with equal code values. Points that are located in the same geosquare receive the same code value. A geosquare is used to encode geographic coordinates (latitude and longitude) into an integer. A larger region is divided into grids to delineate an area on a map with varying resolutions. A geosquare can be used for spatial indexing, spatial binning, proximity searches, location searching, and creating unique place identifiers.  TheST_GeoHashfunction follows a similar process of dividing a region into grids, but has a different encoding.",
            "syntax": "ST_GeoSquare(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A POINT value of data type GEOMETRY or an expression that evaluates to a POINT subtype. The x coordinate (longitude) of the point must be within the range: -180 \u2013 180 . The y coordinate (latitude) of the point must be within the range: -90 \u2013 90 .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "max_depth",
                    "description": "A value of data type INTEGER . The maximum number of times the domain containing the point is subdivided recursively. The value must be an integer from 1 \u2013 32. The default is 32.  The actual final number of the subdivisions is less than or equal to the specified max_depth .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_GeoSquare",
            "description": "ST_GeoSquare recursively subdivides the domain ([-180, 180], [-90, 90]) into equal square regions calledgeosquaresto a specified depth. The subdivision is based on the location of a provided point. One of the geosquares containing the point is subdivided at each step until reaching the maximum depth. The selection of this geosquare is stable, that is, the function result depends on the input arguments only. The function returns a unique value that identifies the final geosquare in which the point is located. The ST_GeoSquare accepts a POINT where the x coordinate is representing the longitude, and the y coordinate is representing the latitude. The longitude and latitude are limited to [-180, 180] and [-90, 90], respectively. The output of ST_GeoSquare can be used as input to theST_GeomFromGeoSquarefunction. There are 360\u00b0 around the arc of the equatorial circumference of the Earth that are divided into two hemispheres (Eastern and Western), each with 180\u00b0 of longitudinal lines (Meridians) from the 0\u00b0 Meridian. By convention, the eastern longitudes are \"+\" (positive) coordinates when projected to an x-axis on a Cartesian plane and the western longitudes are \"-\" (negative) coordinates when projected to an x-axis on a Cartesian plane. There are 90\u00b0 of latitudinal lines north and south of the 0\u00b0 equatorial circumference of the Earth, each parallel to the 0\u00b0 equatorial circumference of the Earth. By convention, the northern latitudinal lines intersect the \"+\" (positive) y-axis when projected to a Cartesian plane, and the southern latitudinal lines intersect the \"-\" (negative) y-axis when projected to a Cartesian plane. The spherical grid formed by the intersection of longitudinal lines and latitudinal lines is converted to a grid projected onto a Cartesian plane with standard positive and negative x-coordinates and positive and negative y-coordinates on the Cartesian plane. The purpose of ST_GeoSquare is to tag or mark close points with equal code values. Points that are located in the same geosquare receive the same code value. A geosquare is used to encode geographic coordinates (latitude and longitude) into an integer. A larger region is divided into grids to delineate an area on a map with varying resolutions. A geosquare can be used for spatial indexing, spatial binning, proximity searches, location searching, and creating unique place identifiers.  TheST_GeoHashfunction follows a similar process of dividing a region into grids, but has a different encoding.",
            "syntax": "ST_GeoSquare(geom,max_depth)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A POINT value of data type GEOMETRY or an expression that evaluates to a POINT subtype. The x coordinate (longitude) of the point must be within the range: -180 \u2013 180 . The y coordinate (latitude) of the point must be within the range: -90 \u2013 90 .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "max_depth",
                    "description": "A value of data type INTEGER . The maximum number of times the domain containing the point is subdivided recursively. The value must be an integer from 1 \u2013 32. The default is 32.  The actual final number of the subdivisions is less than or equal to the specified max_depth .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_InteriorRingN",
            "description": "ST_InteriorRingN returns a closed linestring corresponding to the interior ring of an input polygon at the index position. The dimension of the returned geometry is the same as that of the input geometry.",
            "syntax": "ST_InteriorRingN(geom,index)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "index",
                    "description": "A value of data type INTEGER that represents the position of a ring of a one-based index.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Intersects",
            "description": "ST_Intersects returns true if the 2D projections of the two input geometries have at least one point in common.",
            "syntax": "ST_Intersects(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Intersection",
            "description": "ST_Intersection returns a geometry representing the point-set intersection of two geometries. That is, it returns the portion of the two input geometries that is shared between them.",
            "syntax": "ST_Intersection(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_IsPolygonCCW",
            "description": "ST_IsPolygonCCW returns true if the 2D projection of the input polygon or multipolygon is counterclockwise. If the input geometry is a point, linestring, multipoint, or multilinestring, then true is returned. For geometry collections, ST_IsPolygonCCW returns true if all the geometries in the collection are counterclockwise.",
            "syntax": "ST_IsPolygonCCW(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_IsPolygonCW",
            "description": "ST_IsPolygonCW returns true if the 2D projection of the input polygon or multipolygon is clockwise. If the input geometry is a point, linestring, multipoint, or multilinestring, then true is returned. For geometry collections, ST_IsPolygonCW returns true if all the geometries in the collection are clockwise.",
            "syntax": "ST_IsPolygonCW(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_IsClosed",
            "description": "ST_IsClosed returns true if the 2D projection of the input geometry is closed. The following rules define a closed geometry: The input geometry is a point or a multipoint. The input geometry is a linestring, and the start and end points of the linestring coincide. The input geometry is a nonempty multilinestring and all its linestrings are closed. The input geometry is a nonempty polygon, all polygon's rings are nonempty, and the start and end points of all its rings coincide. The input geometry is a nonempty multipolygon and all its polygons are closed. The input geometry is a nonempty geometry collection and all its components are closed.",
            "syntax": "ST_IsClosed(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_IsCollection",
            "description": "ST_IsCollection returns true if the input geometry is one of the following subtypes:GEOMETRYCOLLECTION,MULTIPOINT,MULTILINESTRING, orMULTIPOLYGON.",
            "syntax": "ST_IsCollection(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_IsEmpty",
            "description": "ST_IsEmpty returns true if the input geometry is empty. A geometry is not empty if it contains at least one nonempty point. ST_IsEmpty returns true if the input geometry has at least one nonempty point.",
            "syntax": "ST_IsEmpty(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_IsRing",
            "description": "ST_IsRing returns true if the input linestring is a ring. A linestring is a ring if it is closed and simple.",
            "syntax": "ST_IsRing(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The geometry must be a LINESTRING .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_IsSimple",
            "description": "ST_IsSimple returns true if the 2D projection of the input geometry is simple. For more information about the definition of a simple geometry, seeGeometric simplicity.",
            "syntax": "ST_IsSimple(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_IsValid",
            "description": "ST_IsValid returns true if the 2D projection of the input geometry is valid. For more information about the definition of a valid geometry, seeGeometric validity.",
            "syntax": "ST_IsValid(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Length",
            "description": "For a linear geometry, ST_Length returns the Cartesian length of a 2D projection. The length units are the same as the units in which the coordinates of the input geometry are expressed. The function returns zero (0) for points, multipoints, and areal geometries. When the input is a geometry collection, the function returns the sum of the lengths of the geometries in the collection. For a geography, ST_Length returns the geodesic length of the 2D projection of an input linear geography computed on the spheroid determined by the SRID. The unit of length is in meters. The function returns zero (0) for points, multipoints, and areal geographies. When the input is a geometry collection, the function returns the sum of the lengths of the geographies in the collection.",
            "syntax": "ST_Length(geo)",
            "arguments": [
                {
                    "name": "geo",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY ,  or an expression that evaluates to a GEOMETRY or GEOGRAPHY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_LengthSphere",
            "description": "ST_LengthSphere returns the length of a linear geometry in meters. For point, multipoint, and areal geometries, ST_LengthSphere returns 0. For geometry collections, ST_LengthSphere returns the total length of the linear geometries in the collection in meters. ST_LengthSphere interprets the coordinates of each point of the input geometry as longitude and latitude in degrees. For 3DZ, 3DM, or 4D geometries, only the first two coordinates are used.",
            "syntax": "ST_LengthSphere(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_LineFromMultiPoint",
            "description": "ST_LineFromMultiPoint returns a linestring from an input multipoint geometry. The order of the points is preserved. The spatial reference system identifier (SRID) of the returned geometry is the same as that of the input geometry. The dimension of the returned geometry is the same as that of the input geometry.",
            "syntax": "ST_LineFromMultiPoint(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be MULTIPOINT .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_LineInterpolatePoint",
            "description": "ST_LineInterpolatePoint returns a point along a line at a fractional distance from the start of the line. To determine point equality, ST_LineInterpolatePoint operates on the 2D projection of the input geometry. If the input geometry is empty, a copy of it is returned in the same dimension as the input. For 3DZ, 3DM, and 4D geometries, thezormcoordinate is the average of thezormcoordinates of the segment where the point lies.",
            "syntax": "ST_LineInterpolatePoint(geom,fraction)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype is LINESTRING .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "fraction",
                    "description": "A value of data type DOUBLE PRECISION that represents the position of a point along the linestring for the line. The value is a fraction in the range 0\u20131, inclusive.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_M",
            "description": "ST_M returns themcoordinate of an input point.",
            "syntax": "ST_M(point)",
            "arguments": [
                {
                    "name": "point",
                    "description": "A POINT value of data type GEOMETRY .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_MakeEnvelope",
            "description": "ST_MakeEnvelope returns a geometry as follows: If the input coordinates specify a point, then the returned geometry is a point. If the input coordinates specify a line, then the returned geometry is a linestring. Otherwise, the returned geometry is a polygon, where the input coordinates specify the lower-left and upper-right corners of a box. If provided, the spatial reference system identifier (SRID) value of the returned geometry is set to the input SRID value.",
            "syntax": "ST_MakeEnvelope(xmin,ymin,xmax,ymax)",
            "arguments": [
                {
                    "name": "xmin",
                    "description": "A value of data type DOUBLE PRECISION . This value is the first coordinate of the lower-left corner of a box.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "ymin",
                    "description": "A value of data type DOUBLE PRECISION . This value is the second coordinate of the lower-left corner of a box.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "xmax",
                    "description": "A value of data type DOUBLE PRECISION . This value is the first coordinate of the upper-right corner of a box.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "ymax",
                    "description": "A value of data type DOUBLE PRECISION . This value is the second coordinate of the upper-right corner of a box.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "srid",
                    "description": "A value of data type INTEGER that represents a spatial reference system identifier (SRID). If the SRID value is not provided, then it is set to zero.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_MakeEnvelope",
            "description": "ST_MakeEnvelope returns a geometry as follows: If the input coordinates specify a point, then the returned geometry is a point. If the input coordinates specify a line, then the returned geometry is a linestring. Otherwise, the returned geometry is a polygon, where the input coordinates specify the lower-left and upper-right corners of a box. If provided, the spatial reference system identifier (SRID) value of the returned geometry is set to the input SRID value.",
            "syntax": "ST_MakeEnvelope(xmin,ymin,xmax,ymax,srid)",
            "arguments": [
                {
                    "name": "xmin",
                    "description": "A value of data type DOUBLE PRECISION . This value is the first coordinate of the lower-left corner of a box.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "ymin",
                    "description": "A value of data type DOUBLE PRECISION . This value is the second coordinate of the lower-left corner of a box.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "xmax",
                    "description": "A value of data type DOUBLE PRECISION . This value is the first coordinate of the upper-right corner of a box.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "ymax",
                    "description": "A value of data type DOUBLE PRECISION . This value is the second coordinate of the upper-right corner of a box.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "srid",
                    "description": "A value of data type INTEGER that represents a spatial reference system identifier (SRID). If the SRID value is not provided, then it is set to zero.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_MakeLine",
            "description": "ST_MakeLine creates a linestring from the input geometries. The dimension of the returned geometry is the same as that of the input geometries. Both input geometries must of the same dimension.",
            "syntax": "ST_MakeLine(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be POINT , LINESTRING , or MULTIPOINT .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be POINT , LINESTRING , or MULTIPOINT .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_MakePoint",
            "description": "ST_MakePoint returns a point geometry whose coordinate values are the input values.",
            "syntax": "ST_MakePoint(x,y)",
            "arguments": [
                {
                    "name": "x",
                    "description": "A value of data type DOUBLE PRECISION representing the first coordinate.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "y",
                    "description": "A value of data type DOUBLE PRECISION representing the second coordinate.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "z",
                    "description": "A value of data type DOUBLE PRECISION representing the third coordinate.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "m",
                    "description": "A value of data type DOUBLE PRECISION representing the fourth coordinate.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_MakePoint",
            "description": "ST_MakePoint returns a point geometry whose coordinate values are the input values.",
            "syntax": "ST_MakePoint(x,y,z)",
            "arguments": [
                {
                    "name": "x",
                    "description": "A value of data type DOUBLE PRECISION representing the first coordinate.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "y",
                    "description": "A value of data type DOUBLE PRECISION representing the second coordinate.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "z",
                    "description": "A value of data type DOUBLE PRECISION representing the third coordinate.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "m",
                    "description": "A value of data type DOUBLE PRECISION representing the fourth coordinate.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_MakePoint",
            "description": "ST_MakePoint returns a point geometry whose coordinate values are the input values.",
            "syntax": "ST_MakePoint(x,y,z,m)",
            "arguments": [
                {
                    "name": "x",
                    "description": "A value of data type DOUBLE PRECISION representing the first coordinate.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "y",
                    "description": "A value of data type DOUBLE PRECISION representing the second coordinate.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "z",
                    "description": "A value of data type DOUBLE PRECISION representing the third coordinate.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "m",
                    "description": "A value of data type DOUBLE PRECISION representing the fourth coordinate.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_MakePolygon",
            "description": "ST_MakePolygon has two variants that return a polygon. One takes a single geometry, and another takes two geometries. The input of the first variant is a linestring that defines the outer ring of the output polygon. The input of the second variant is a linestring and a multilinestring. Both of these are empty or closed. The boundary of the exterior ring of the output polygon is the input linestring, and the boundaries of the interior rings of the polygon are the linestrings in the input multilinestring. If the input linestring is empty, an empty polygon is returned. Empty linestrings in the multilinestring are disregarded. The spatial reference system identifier (SRID) of the resulting geometry is the common SRID of the two input geometries. The dimension of the returned geometry is the same as that of the input geometries. The exterior ring and interior rings must of the same dimension.",
            "syntax": "ST_MakePolygon(geom1)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be LINESTRING . The linestring value must be closed or empty.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be MULTILINESTRING .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_MakePolygon",
            "description": "ST_MakePolygon has two variants that return a polygon. One takes a single geometry, and another takes two geometries. The input of the first variant is a linestring that defines the outer ring of the output polygon. The input of the second variant is a linestring and a multilinestring. Both of these are empty or closed. The boundary of the exterior ring of the output polygon is the input linestring, and the boundaries of the interior rings of the polygon are the linestrings in the input multilinestring. If the input linestring is empty, an empty polygon is returned. Empty linestrings in the multilinestring are disregarded. The spatial reference system identifier (SRID) of the resulting geometry is the common SRID of the two input geometries. The dimension of the returned geometry is the same as that of the input geometries. The exterior ring and interior rings must of the same dimension.",
            "syntax": "ST_MakePolygon(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be LINESTRING . The linestring value must be closed or empty.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be MULTILINESTRING .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_MemSize",
            "description": "ST_MemSize returns the amount of memory space (in bytes) used by the input geometry. This size depends on the Amazon Redshift internal representation of the geometry and thus can change if the internal representation changes. You can use this size as an indication of the relative size of geometry objects in Amazon Redshift.",
            "syntax": "ST_MemSize(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_MMax",
            "description": "ST_MMax returns the maximummcoordinate of an input geometry.",
            "syntax": "ST_MMax(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_MMin",
            "description": "ST_MMin returns the minimummcoordinate of an input geometry.",
            "syntax": "ST_MMin(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Multi",
            "description": "ST_Multi converts a geometry to the corresponding multitype. If the input geometry is already a multitype or a geometry collection, a copy of it is returned. If the input geometry is a point, linestring, or polygon, then a multipoint, multilinestring, or multipolygon, respectively, that contains the input geometry is returned.",
            "syntax": "ST_Multi(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_NDims",
            "description": "ST_NDims returns the coordinate dimension of a geometry. ST_NDims doesn't consider the topological dimension of a geometry. Instead, it returns a constant value depending on the dimension of the geometry.",
            "syntax": "ST_NDims(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_NPoints",
            "description": "ST_NPoints returns the number of nonempty points in an input geometry or geography.",
            "syntax": "ST_NPoints(geo)",
            "arguments": [
                {
                    "name": "geo",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY , or an expression that evaluates to a GEOMETRY or GEOGRAPHY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_NRings",
            "description": "ST_NRings returns the number of rings in an input geometry.",
            "syntax": "ST_NRings(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_NumGeometries",
            "description": "ST_NumGeometries returns the number of geometries in an input geometry.",
            "syntax": "ST_NumGeometries(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_NumInteriorRings",
            "description": "ST_NumInteriorRings returns the number of rings in an input polygon geometry.",
            "syntax": "ST_NumInteriorRings(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_NumPoints",
            "description": "ST_NumPoints returns the number of points in an input geometry.",
            "syntax": "ST_NumPoints(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Perimeter",
            "description": "For an input areal geometry, ST_Perimeter returns the Cartesian perimeter (length of the boundary) of the 2D projection. The perimeter units are the same as the units in which the coordinates of the input geometry are expressed. The function returns zero (0) for points, multipoints, and linear geometries. When the input is a geometry collection, the function returns the sum of the perimeters of the geometries in the collection. For an input geography, ST_Perimeter returns the geodesic perimeter (length of the boundary) of the 2D projection of an input areal geography computed on the spheroid determined by the SRID. The unit of perimeter is in meters. The function returns zero (0) for points, multipoints, and linear geographies. When the input is a geometry collection, the function returns the sum of the perimeters of the geographies in the collection.",
            "syntax": "ST_Perimeter(geo)",
            "arguments": [
                {
                    "name": "geo",
                    "description": "A value of data type GEOMETRY or GEOGRAPHY , or an expression that evaluates to a GEOMETRY or GEOGRAPHY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Point",
            "description": "ST_Point returns a point geometry from the input coordinate values.",
            "syntax": "ST_Point(x,y)",
            "arguments": [
                {
                    "name": "x",
                    "description": "A value of data type DOUBLE PRECISION that represents a first coordinate.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "y",
                    "description": "A value of data type DOUBLE PRECISION that represents a second coordinate.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_PointN",
            "description": "ST_PointN returns a point in a linestring as specified by an index value. Negative index values are counted backward from the end of the linestring, so that -1 is the last point. The dimension of the returned geometry is the same as that of the input geometry.",
            "syntax": "ST_PointN(geom,index)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be LINESTRING .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "index",
                    "description": "A value of data type INTEGER that represents the index of a point in a linestring.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Points",
            "description": "ST_Points returns a multipoint geometry containing all nonempty points in the input geometry. ST_Points doesn't remove points that are duplicated in the input, including the start and end points of ring geometries.",
            "syntax": "ST_Points(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Polygon",
            "description": "ST_Polygon returns a polygon geometry whose outer ring is the input linestring with the value that was input for the spatial reference system identifier (SRID). The dimension of the returned geometry is the same as that of the input geometry.",
            "syntax": "ST_Polygon(linestring,srid)",
            "arguments": [
                {
                    "name": "linestring",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be LINESTRING that represents a linestring. The linestring value must be closed.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "srid",
                    "description": "A value of data type INTEGER that represents a SRID.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_RemovePoint",
            "description": "ST_RemovePoint returns a linestring geometry that has the point of the input geometry at an index position removed. The index is zero-based. The spatial reference system identifier (SRID) of the result is the same as the input geometry. The dimension of the returned geometry is the same as that of the input geometry.",
            "syntax": "ST_RemovePoint(geom,index)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be LINESTRING .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "index",
                    "description": "A value of data type INTEGER that represents the position of a zero-based index.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Reverse",
            "description": "ST_Reverse reverses the order of the vertices for linear and areal geometries. For point or multipoint geometries, a copy of the original geometry is returned. For geometry collections, ST_Reverse reverses the order of the vertices for each of the geometries in the collection. The dimension of the returned geometry is the same as that of the input geometry.",
            "syntax": "ST_Reverse(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_SetPoint",
            "description": "ST_SetPoint returns a linestring with updated coordinates with respect to the input linestring's position as specified by the index. The new coordinates are the coordinates of the input point. The dimension of the returned geometry is the same as that of thegeom1value. Ifgeom1andgeom2have different dimensions,geom2is projected to the dimension ofgeom1.",
            "syntax": "ST_SetPoint(geom1,index,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be LINESTRING .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "index",
                    "description": "A value of data type INTEGER that represents the position of an index. A 0 refers to the first point of the linestring from the left, 1 refers to the second point, and so on. The index can be a negative value. A -1 refers to the first point of the linestring from the right, -2 refers to the second point of the linestring from the right, and so on.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be POINT .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_SetSRID",
            "description": "ST_SetSRID returns a geometry that is the same as input geometry, except updated with the value input for the spatial reference system identifier (SRID).",
            "syntax": "ST_SetSRID(geom,srid)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "srid",
                    "description": "A value of data type INTEGER that represents a SRID.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Simplify",
            "description": "ST_Simplify returns a simplified copy of the input geometry using the Ramer-Douglas-Peucker algorithm with the given tolerance. The topology of the input geometry might not be preserved. For more information about the algorithm, seeRamer\u2013Douglas\u2013Peucker algorithmin Wikipedia. When ST_Simplify calculates distances to simplify a geometry, ST_Simplify operates on the 2D projection of the input geometry.",
            "syntax": "ST_Simplify(geom,tolerance)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "tolerance",
                    "description": "A value of data type DOUBLE PRECISION that represents the tolerance level of the Ramer-Douglas-Peucker algorithm. If tolerance is a negative number, then zero is used.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_SRID",
            "description": "ST_SRID returns the spatial reference system identifier (SRID) of an input geometry.  For more information about an SRID, seeQuerying spatial data in Amazon Redshift.",
            "syntax": "ST_SRID(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_StartPoint",
            "description": "ST_StartPoint returns the first point of an input linestring. The spatial reference system identifier (SRID) value of the result is the same as that of the input geometry. The dimension of the returned geometry is the same as that of the input geometry.",
            "syntax": "ST_StartPoint(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. The subtype must be LINESTRING .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Touches",
            "description": "ST_Touches returns true if the 2D projections of the two input geometries touch. The two geometries touch if they are nonempty, intersect, and have no interior points in common.",
            "syntax": "ST_Touches(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Transform",
            "description": "ST_Transform returns a new geometry with coordinates that are transformed in a spatial reference system defined by the input spatial reference system identifier (SRID).",
            "syntax": "ST_Transform(geom,srid)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "srid",
                    "description": "A value of data type INTEGER that represents an SRID.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Union",
            "description": "ST_Union returns a geometry representing the union of two geometries. That is, it merges the input geometries to produce a resulting geometry with no overlaps.",
            "syntax": "ST_Union(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Within",
            "description": "ST_Within returns true if the 2D projection of the first input geometry is within the 2D projection of the second input geometry. For example, geometryAis within geometryBif every point inAis a point inBand their interiors have nonempty intersection. ST_Within(A,B) is equivalent to ST_Contains(B,A).",
            "syntax": "ST_Within(geom1,geom2)",
            "arguments": [
                {
                    "name": "geom1",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type. This value is compared with geom2 to determine if it is within geom2 .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "geom2",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_X",
            "description": "ST_X returns the first coordinate of an input point.",
            "syntax": "ST_X(point)",
            "arguments": [
                {
                    "name": "point",
                    "description": "A POINT value of data type GEOMETRY .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_XMax",
            "description": "ST_XMax returns the maximum first coordinate of an input geometry.",
            "syntax": "ST_XMax(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_XMin",
            "description": "ST_XMin returns the minimum first coordinate of an input geometry.",
            "syntax": "ST_XMin(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Y",
            "description": "ST_Y returns the second coordinate of an input point.",
            "syntax": "ST_Y(point)",
            "arguments": [
                {
                    "name": "point",
                    "description": "A POINT value of data type GEOMETRY .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_YMax",
            "description": "ST_YMax returns the maximum second coordinate of an input geometry.",
            "syntax": "ST_YMax(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_YMin",
            "description": "ST_YMin returns the minimum second coordinate of an input geometry.",
            "syntax": "ST_YMin(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_Z",
            "description": "ST_Z returns thezcoordinate of an input point.",
            "syntax": "ST_Z(point)",
            "arguments": [
                {
                    "name": "point",
                    "description": "A POINT value of data type GEOMETRY .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_ZMax",
            "description": "ST_ZMax returns the maximumzcoordinate of an input geometry.",
            "syntax": "ST_ZMax(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ST_ZMin",
            "description": "ST_ZMin returns the minimumzcoordinate of an input geometry.",
            "syntax": "ST_ZMin(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SupportsBBox",
            "description": "SupportsBBox returns true if the input geometry supports encoding with a precomputed bounding box. For more information about support for bounding boxes, seeBounding box.",
            "syntax": "SupportsBBox(geom)",
            "arguments": [
                {
                    "name": "geom",
                    "description": "A value of data type GEOMETRY or an expression that evaluates to a GEOMETRY type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "e",
            "description": "Concatenates two expressions on either side of the||symbol and returns the concatenated expression. Similar toCONCAT function. If one or both of the expressions is null, the result of the concatenation isNULL.",
            "syntax": "e(x",
            "arguments": [
                {
                    "name": "expression1",
                    "description": "A CHAR string, a VARCHAR string, a binary expression, or an expression that evaluates to one of these types.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "expression2",
                    "description": "A CHAR string, a VARCHAR string, a binary expression, or an expression that evaluates to one of these types.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "ASCII",
            "description": "The ASCII function returns the ASCII code, or the Unicode code-point, of the first character in the string that you specify. The function returns0if the string is empty. It returnsNULLif the string is null.",
            "syntax": "ASCII('string')",
            "arguments": [
                {
                    "name": "string",
                    "description": "A CHAR string or a VARCHAR string.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "BPCHARCMP",
            "description": "Compares the value of two strings and returns an integer. If the strings are identical, the function returns0. If the first string is greater alphabetically, the function returns1. If the second string is greater, the function returns-1. For multibyte characters, the comparison is based on the byte encoding. Synonym ofBTTEXT_PATTERN_CMP function.",
            "syntax": "BPCHARCMP(string1,string2)",
            "arguments": [
                {
                    "name": "string1",
                    "description": "A CHAR string or a VARCHAR string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "string2",
                    "description": "A CHAR string or a VARCHAR string.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "BTRIM",
            "description": "The BTRIM function trims a string by removing leading and trailing blanks or by removing leading and trailing characters that match an optional specified string.",
            "syntax": "BTRIM(string[,trim_chars] )",
            "arguments": [
                {
                    "name": "string",
                    "description": "The input VARCHAR string to be trimmed.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "trim_chars",
                    "description": "The VARCHAR string containing the characters to be matched.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "CHARINDEX",
            "description": "Returns the location of the specified substring within a string. SeePOSITION functionandSTRPOS functionfor similar functions.",
            "syntax": "CHARINDEX(substring,string)",
            "arguments": [
                {
                    "name": "substring",
                    "description": "The substring to search for within the string .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "string",
                    "description": "The string or column to be searched.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "CHR",
            "description": "The CHR function returns the character that matches the ASCII code point value specified by the input parameter.",
            "syntax": "CHR(number)",
            "arguments": [
                {
                    "name": "number",
                    "description": "The input parameter is an INTEGER that represents an ASCII code point value.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "COLLATE",
            "description": "The COLLATE function overrides the collation of a string column or expression. For information on how to create tables using database collation, seeCREATE TABLE. For information on how to create databases using database collation, seeCREATE DATABASE.",
            "syntax": "COLLATE(string,'case_sensitive'|'case_insensitive');",
            "arguments": [
                {
                    "name": "string",
                    "description": "A string column or expression that you want to override.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "'case_sensitive'|'case_insensitive'",
                    "description": "A string constant of a collation name. Amazon Redshift only supports case_sensitive or case_insensitive .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "CONCAT",
            "description": "The CONCAT function concatenates two expressions and returns the resulting expression. To concatenate more than two expressions, use nested CONCAT functions. The concatenation operator (||) between two expressions produces the same results as the CONCAT function.",
            "syntax": "CONCAT(expression1,expression2)",
            "arguments": [
                {
                    "name": "expression1,expression2",
                    "description": "Both arguments can be a fixed-length character string, a variable-length character string, a binary expression, or an expression that evaluates to one of these inputs.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "CRC32",
            "description": "CRC32 is a function used for error detection. The function uses a CRC32 algorithm to detect changes between source and target data. The CRC32 function converts a variable-length string into an 8-character string that is a text representation of the hexadecimal value of a 32 bit-binary sequence. To detect changes between source and target data, use the CRC32 function on the source data and store the output. Then, use the CRC32 function on the target data and compare that output to the output from the source data. The outputs will be the same if the data was not modified, and the outputs will be different if the data was modified.",
            "syntax": "CRC32(string)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A CHAR string, a VARCHAR string, or an expression that implicitly evaluates to a CHAR or VARCHAR type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DIFFERENCE",
            "description": "The DIFFERENCE function compares the American Soundex codes of two strings. The function returns anINTEGERto indicate the number of matching characters between the Soundex codes. A Soundex code is a string that is four characters long. A Soundex code represents how a word sounds rather than how it is spelled. For example,SmithandSmythhave the same Soundex code.",
            "syntax": "DIFFERENCE(string1,string2)",
            "arguments": [
                {
                    "name": "string1",
                    "description": "A CHAR string, a VARCHAR string, or an expression that implicitly evaluates to a CHAR or VARCHAR type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "string2",
                    "description": "A CHAR string, a VARCHAR string, or an expression that implicitly evaluates to a CHAR or VARCHAR type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "INITCAP",
            "description": "Capitalizes the first letter of each word in a specified string. INITCAP supports UTF-8 multibyte characters, up to a maximum of four bytes per character.",
            "syntax": "INITCAP(string)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A CHAR string, a VARCHAR string, or an expression that implicitly evaluates to a CHAR or VARCHAR type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "LEFT",
            "description": "These functions return the specified number of leftmost or rightmost characters from a character string. The number is based on the number of characters, not bytes, so that multibyte characters are counted as single characters.",
            "syntax": "LEFT(string,integer)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A CHAR string, a VARCHAR string, or any expression that evaluates to a CHAR or VARCHAR string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "integer",
                    "description": "A positive integer.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "LEFT",
            "description": "These functions return the specified number of leftmost or rightmost characters from a character string. The number is based on the number of characters, not bytes, so that multibyte characters are counted as single characters.",
            "syntax": "LEFT(string,integer)\n\nRIGHT(string,integer)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A CHAR string, a VARCHAR string, or any expression that evaluates to a CHAR or VARCHAR string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "integer",
                    "description": "A positive integer.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "LEN",
            "description": "Returns the length of the specified string as the number of characters.",
            "syntax": "LEN(expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "A CHAR string, a VARCHAR string, a VARBYTE expression, or an expression that implicitly evaluates to a CHAR , VARCHAR , or VARBYTE type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "LOWER",
            "description": "Converts a string to lowercase. LOWER supports UTF-8 multibyte characters, up to a maximum of four bytes per character.",
            "syntax": "LOWER(string)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A VARCHAR string or any expression that evaluates to the VARCHAR type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "LPAD",
            "description": "These functions prepend or append characters to a string, based on a specified length.",
            "syntax": "LPAD(string1,length, [string2])",
            "arguments": [
                {
                    "name": "string1",
                    "description": "A CHAR string, a VARCHAR string, or an expression that implicitly evaluates to a CHAR or VARCHAR type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "length",
                    "description": "An integer that defines the length of the result of the function. The length of a string is based on the number of characters, not bytes, so that multi-byte characters are counted as single characters. If string1 is longer than the specified length, it is truncated (on the right). If length is zero or a negative number, the result of the function is an empty string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "string2",
                    "description": "(Optional) One or more characters that are prepended or appended to string1 . If this argument is not specified, spaces are used.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "RPAD",
            "description": "These functions prepend or append characters to a string, based on a specified length.",
            "syntax": "RPAD(string1,length, [string2])",
            "arguments": [
                {
                    "name": "string1",
                    "description": "A CHAR string, a VARCHAR string, or an expression that implicitly evaluates to a CHAR or VARCHAR type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "length",
                    "description": "An integer that defines the length of the result of the function. The length of a string is based on the number of characters, not bytes, so that multi-byte characters are counted as single characters. If string1 is longer than the specified length, it is truncated (on the right). If length is zero or a negative number, the result of the function is an empty string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "string2",
                    "description": "(Optional) One or more characters that are prepended or appended to string1 . If this argument is not specified, spaces are used.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "LTRIM",
            "description": "Trims characters from the beginning of a string. Removes the longest string containing only characters in the trim characters list. Trimming is complete when a trim character does not appear in the input string.",
            "syntax": "LTRIM(string[,trim_chars] )",
            "arguments": [
                {
                    "name": "string",
                    "description": "A string column, expression, or string literal to be trimmed.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "trim_chars",
                    "description": "A string column, expression, or string literal that represents the characters to be trimmed from the beginning of string . If not specified, a space is used as the trim character.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "OCTETINDEX",
            "description": "The OCTETINDEX function returns the location of a substring within a string as a number of bytes.",
            "syntax": "OCTETINDEX(substring,string)",
            "arguments": [
                {
                    "name": "substring",
                    "description": "A CHAR string, a VARCHAR string, or an expression that implicitly evaluates to a CHAR or VARCHAR type.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "string",
                    "description": "A CHAR string, a VARCHAR string, or an expression that implicitly evaluates to a CHAR or VARCHAR type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "OCTET_LENGTH",
            "description": "Returns the length of the specified string as the number of bytes.",
            "syntax": "OCTET_LENGTH(expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "A CHAR string, a VARCHAR string, a VARBYTE expression, or an expression that implicitly evaluates to a CHAR , VARCHAR , or VARBYTE type.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "QUOTE_IDENT",
            "description": "The QUOTE_IDENT function returns the specified string as a string with a leading double quotation mark and a trailing double quotation mark. The function output can be used as an identifier in a SQL statement. The function appropriately doubles any embedded double quotation marks. QUOTE_IDENT adds double quotation marks only where necessary to create a valid identifier, when the string contains non-identifier characters or would otherwise be folded to lowercase. To always return a single-quoted string, useQUOTE_LITERAL.",
            "syntax": "QUOTE_IDENT(string)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A CHAR or VARCHAR string.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "QUOTE_LITERAL",
            "description": "The QUOTE_LITERAL function returns the specified string as a single quoted string so that it can be used as a string literal in a SQL statement. If the input parameter is a number, QUOTE_LITERAL treats it as a string. Appropriately doubles any embedded single quotation marks and backslashes.",
            "syntax": "QUOTE_LITERAL(string)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A CHAR or VARCHAR string.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "REGEXP_COUNT",
            "description": "Searches a string for a regular expression pattern and returns an integer that indicates the number of times the specified pattern occurs in the string. If no match is found, then the function returns0. For more information about regular expressions, seePOSIX operatorsandRegular expressionin Wikipedia.",
            "syntax": "REGEXP_COUNT(source_string,pattern[,position[,parameters] ] )",
            "arguments": [
                {
                    "name": "source_string",
                    "description": "A CHAR or VARCHAR string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "pattern",
                    "description": "A UTF-8 string literal that represents a regular expression pattern. For more information, see POSIX operators .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "position",
                    "description": "(Optional) A positive INTEGER that indicates the position within source_string to begin searching. The position is based on the number of characters, not bytes, so that multibyte characters are counted as single characters. The default is 1 . If position is less than 1 , the search begins at the first character of source_string . If position is greater than the number of characters in source_string , the result is 0 .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "parameters",
                    "description": "(Optional) One or more string literals that indicate how the function matches the pattern. The possible values are the following: c \u2013 Perform case-sensitive matching. The default is to use case-sensitive matching. i \u2013 Perform case-insensitive matching. p \u2013 Interpret the pattern with Perl Compatible Regular Expression (PCRE) dialect. For more information about PCRE, see Perl Compatible Regular Expressions in Wikipedia.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "REGEXP_INSTR",
            "description": "Searches a string for a regular expression pattern and returns an integer that indicates the beginning position or ending position of the matched substring. If no match is found, then the function returns0. REGEXP_INSTR is similar to thePOSITIONfunction, but lets you search a string for a regular expression pattern. For more information about regular expressions, seePOSIX operatorsandRegular expressionin Wikipedia.",
            "syntax": "REGEXP_INSTR(source_string,pattern[,position[,occurrence] [,option[,parameters] ] ] ] )",
            "arguments": [
                {
                    "name": "source_string",
                    "description": "A string expression, such as a column name, to be searched.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "pattern",
                    "description": "A UTF-8 string literal that represents a regular expression pattern. For more information, see POSIX operators .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "position",
                    "description": "(Optional) A positive INTEGER that indicates the position within source_string to begin searching. The position is based on the number of characters, not bytes, so that multibyte characters are counted as single characters. The default is 1 . If position is less than 1 , the search begins at the first character of source_string . If position is greater than the number of characters in source_string , the result is 0 .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "occurrence",
                    "description": "(Optional) A positive INTEGER that indicates which occurrence of the pattern to use. REGEXP_INSTR skips the first occurrence -1 matches. The default is 1 . If occurrence is less than 1 or greater than the number of characters in source_string , the search is ignored and the result is 0 .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "option",
                    "description": "(Optional) A value that indicates whether to return the position of the first character of the match ( 0 ) or the position of the first character following the end of the match ( 1 ). A nonzero value is the same as 1 . The default value is 0 .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "parameters",
                    "description": "(Optional) One or more string literals that indicate how the function matches the pattern. The possible values are the following: c \u2013 Perform case-sensitive matching. The default is to use case-sensitive matching. i \u2013 Perform case-insensitive matching. e \u2013 Extract a substring using a subexpression. If pattern includes a subexpression, REGEXP_INSTR matches a substring using the first subexpression in pattern . REGEXP_INSTR considers only the first subexpression; additional subexpressions are ignored. If the pattern doesn't have a subexpression, REGEXP_INSTR ignores the 'e' parameter. p \u2013 Interpret the pattern with Perl Compatible Regular Expression (PCRE) dialect. For more information about PCRE, see Perl Compatible Regular Expressions in Wikipedia.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "REGEXP_REPLACE",
            "description": "Searches a string for a regular expression pattern and replaces every occurrence of the pattern with the specified string. REGEXP_REPLACE is similar to theREPLACE function, but lets you search a string for a regular expression pattern. For more information about regular expressions, seePOSIX operatorsandRegular expressionin Wikipedia. REGEXP_REPLACE is similar to theTRANSLATE functionand theREPLACE function, except that TRANSLATE makes multiple single-character substitutions and REPLACE substitutes one entire string with another string, while REGEXP_REPLACE lets you search a string for a regular expression pattern.",
            "syntax": "REGEXP_REPLACE(source_string,pattern[,replace_string[ ,position[,parameters] ] ] )",
            "arguments": [
                {
                    "name": "source_string",
                    "description": "A CHAR or VARCHAR string expression, such as a column name, to be searched.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "pattern",
                    "description": "A UTF-8 string literal that represents a regular expression pattern. For more information, see POSIX operators .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "replace_string",
                    "description": "(Optional) A CHAR or VARCHAR string expression, such as a column name, that will replace each occurrence of pattern. The default is an empty string ( \"\" ).",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "position",
                    "description": "(Optional) A positive integer that indicates the position within source_string to begin searching. The position is based on the number of characters, not bytes, so that multibyte characters are counted as single characters. The default is 1 . If position is less than 1 , the search begins at the first character of source_string . If position is greater than the number of characters in source_string , the result is source_string .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "parameters",
                    "description": "(Optional) One or more string literals that indicate how the function matches the pattern. The possible values are the following: c \u2013 Perform case-sensitive matching. The default is to use case-sensitive matching. i \u2013 Perform case-insensitive matching. p \u2013 Interpret the pattern with Perl Compatible Regular Expression (PCRE) dialect. For more information about PCRE, see Perl Compatible Regular Expressions in Wikipedia.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "REGEXP_SUBSTR",
            "description": "Returns characters from a string by searching it for a regular expression pattern. REGEXP_SUBSTR is similar to theSUBSTRING functionfunction, but lets you search a string for a regular expression pattern. If the function can't match the regular expression to any characters in the string, it returns an empty string. For more information about regular expressions, seePOSIX operatorsandRegular expressionin Wikipedia.",
            "syntax": "REGEXP_SUBSTR(source_string,pattern[,position[,occurrence[,parameters] ] ] )",
            "arguments": [
                {
                    "name": "source_string",
                    "description": "A string expression to be searched.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "pattern",
                    "description": "A UTF-8 string literal that represents a regular expression pattern. For more information, see POSIX operators .",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "position",
                    "description": "A positive integer that indicates the position within source_string to begin searching. The position is based on the number of characters, not bytes, so that multi-byte characters are counted as single characters. The default is 1. If position is less than 1, the search begins at the first character of source_string . If position is greater than the number of characters in source_string , the result is an empty string (\"\").",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "occurrence",
                    "description": "A positive integer that indicates which occurrence of the pattern to use. REGEXP_SUBSTR skips the first occurrence -1 matches. The default is 1. If occurrence is less than 1 or greater than the number of characters in source_string , the search is ignored and the result is NULL.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "parameters",
                    "description": "One or more string literals that indicate how the function matches the pattern. The possible values are the following: c \u2013 Perform case-sensitive matching. The default is to use case-sensitive matching. i \u2013 Perform case-insensitive matching. e \u2013 Extract a substring using a subexpression. If pattern includes a subexpression, REGEXP_SUBSTR matches a substring using the first subexpression in pattern . A subexpression is an expression within the pattern that is bracketed with parentheses. For example, for the pattern 'This is a (\\\\w+)' matches the first expression with the string 'This is a ' followed by a word. Instead of returning pattern , REGEXP_SUBSTR with the e parameter returns only the string inside the subexpression. REGEXP_SUBSTR considers only the first subexpression; additional subexpressions are ignored. If the pattern doesn't have a subexpression, REGEXP_SUBSTR ignores the 'e' parameter. p \u2013 Interpret the pattern with Perl Compatible Regular Expression (PCRE) dialect. For more information about PCRE, see Perl Compatible Regular Expressions in Wikipedia.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "REPEAT",
            "description": "Repeats a string the specified number of times. If the input parameter is numeric, REPEAT treats it as a string. Synonym forREPLICATE function.",
            "syntax": "REPEAT(string,integer)",
            "arguments": [
                {
                    "name": "string",
                    "description": "The first input parameter is the string to be repeated.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "integer",
                    "description": "The second parameter is an INTEGER indicating the number of times to repeat the string.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "REPLACE",
            "description": "Replaces all occurrences of a set of characters within an existing string with other specified characters. REPLACE is similar to theTRANSLATE functionand theREGEXP_REPLACE function, except that TRANSLATE makes multiple single-character substitutions and REGEXP_REPLACE lets you search a string for a regular expression pattern, while REPLACE substitutes one entire string with another string.",
            "syntax": "REPLACE(string,old_chars,new_chars)",
            "arguments": [
                {
                    "name": "string",
                    "description": "CHAR or VARCHAR string to be searched search",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "old_chars",
                    "description": "CHAR or VARCHAR string to replace.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "new_chars",
                    "description": "New CHAR or VARCHAR string replacing the old_string .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "REVERSE",
            "description": "The REVERSE function operates on a string and returns the characters in reverse order. For example,reverse('abcde')returnsedcba. This function works on numeric and date data types as well as character data types; however, in most cases it has practical value for character strings.",
            "syntax": "REVERSE(expression)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "An expression with a character, date, timestamp, or numeric data type that represents the target of the character reversal. All expressions are implicitly converted to VARCHAR strings. Trailing blanks in CHAR strings are ignored.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "RTRIM",
            "description": "The RTRIM function trims a specified set of characters from the end of a string. Removes the longest string containing only characters in the trim characters list. Trimming is complete when a trim character does not appear in the input string.",
            "syntax": "RTRIM(string,trim_chars)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A string column, expression, or string literal to be trimmed.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "trim_chars",
                    "description": "A string column, expression, or string literal that represents the characters to be trimmed from the end of string . If not specified, a space is used as the trim character.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SOUNDEX",
            "description": "The SOUNDEX function returns the American Soundex value consisting of the first letter of the input string followed by a 3\u2013digit encoding of the sounds that represent the English pronunciation of the string that you specify.  For example,SmithandSmythhave the same Soundex value.",
            "syntax": "SOUNDEX(string)",
            "arguments": [
                {
                    "name": "string",
                    "description": "You specify a CHAR or VARCHAR string that you want to convert to an American Soundex code value.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SPLIT_PART",
            "description": "Splits a string on the specified delimiter and returns the part at the specified position.",
            "syntax": "SPLIT_PART(string,delimiter,position)",
            "arguments": [
                {
                    "name": "string",
                    "description": "A string column, expression, or string literal to be split. The string can be CHAR or VARCHAR.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "delimiter",
                    "description": "The delimiter string indicating sections of the input string . If delimiter is a literal, enclose it in single quotation marks.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "position",
                    "description": "Position of the portion of string to return (counting from 1). Must be an integer greater than 0. If position is larger than the number of string portions, SPLIT_PART returns an empty string. If delimiter is not found in string , then the returned value contains the contents of the specified part, which might be the entire string or an empty value.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "STRPOS",
            "description": "Returns the position of a substring within a specified string. SeeCHARINDEX functionandPOSITION functionfor similar functions.",
            "syntax": "STRPOS(string,substring)",
            "arguments": [
                {
                    "name": "string",
                    "description": "The first input parameter is the CHAR or VARCHAR string to be searched.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "substring",
                    "description": "The second parameter is the substring to search for within the string .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "STRTOL",
            "description": "Converts a string expression of a number of the specified base to the equivalent integer value. The converted value must be within the signed 64-bit range.",
            "syntax": "STRTOL(num_string,base)",
            "arguments": [
                {
                    "name": "num_string",
                    "description": "String expression of a number to be converted. If num_string is empty ( '' ) or begins with the null character ( '\\0' ), the converted value is 0 . If num_string is a column containing a NULL value, STRTOL returns NULL . The string can begin with any amount of white space, optionally followed by a single plus ' + ' or minus ' - ' sign to indicate positive or negative. The default is ' + '. If base is 16 , the string can optionally begin with ' 0x '.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "base",
                    "description": "INTEGER between 2 and 36.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SUBSTRING",
            "description": "Returns the subset of a string based on the specified start position. If the input is a character string, the start position and number of characters extracted are based on characters, not bytes, so that multi-byte characters are counted as single characters. If the input is a binary expression, the start position and extracted substring are based on bytes. You can't specify a negative length, but you can specify a negative starting position.",
            "syntax": "SUBSTRING(character_stringFROMstart_position[ FORnumber_characters] )",
            "arguments": [
                {
                    "name": "character_string",
                    "description": "The string to be searched. Non-character data types are treated like a string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "start_position",
                    "description": "The position within the string to begin the extraction, starting at 1. The start_position is based on the number of characters, not bytes, so that multi-byte characters are counted as single characters. This number can be negative.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "number_characters",
                    "description": "The number of characters to extract (the length of the substring). The number_characters is based on the number of characters, not bytes, so that multi-byte characters are counted as single characters. This number cannot be negative.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "binary_expression",
                    "description": "The binary_expression of data type VARBYTE to be searched.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "start_byte",
                    "description": "The position within the binary expression to begin the extraction, starting at 1. This number can be negative.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "number_bytes",
                    "description": "The number of bytes to extract, that is, the length of the substring. This number can't be negative.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SUBSTRING",
            "description": "Returns the subset of a string based on the specified start position. If the input is a character string, the start position and number of characters extracted are based on characters, not bytes, so that multi-byte characters are counted as single characters. If the input is a binary expression, the start position and extracted substring are based on bytes. You can't specify a negative length, but you can specify a negative starting position.",
            "syntax": "SUBSTRING(character_string,start_position,number_characters)",
            "arguments": [
                {
                    "name": "character_string",
                    "description": "The string to be searched. Non-character data types are treated like a string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "start_position",
                    "description": "The position within the string to begin the extraction, starting at 1. The start_position is based on the number of characters, not bytes, so that multi-byte characters are counted as single characters. This number can be negative.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "number_characters",
                    "description": "The number of characters to extract (the length of the substring). The number_characters is based on the number of characters, not bytes, so that multi-byte characters are counted as single characters. This number cannot be negative.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "binary_expression",
                    "description": "The binary_expression of data type VARBYTE to be searched.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "start_byte",
                    "description": "The position within the binary expression to begin the extraction, starting at 1. This number can be negative.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "number_bytes",
                    "description": "The number of bytes to extract, that is, the length of the substring. This number can't be negative.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SUBSTRING",
            "description": "Returns the subset of a string based on the specified start position. If the input is a character string, the start position and number of characters extracted are based on characters, not bytes, so that multi-byte characters are counted as single characters. If the input is a binary expression, the start position and extracted substring are based on bytes. You can't specify a negative length, but you can specify a negative starting position.",
            "syntax": "SUBSTRING(binary_expression,start_byte,number_bytes)",
            "arguments": [
                {
                    "name": "character_string",
                    "description": "The string to be searched. Non-character data types are treated like a string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "start_position",
                    "description": "The position within the string to begin the extraction, starting at 1. The start_position is based on the number of characters, not bytes, so that multi-byte characters are counted as single characters. This number can be negative.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "number_characters",
                    "description": "The number of characters to extract (the length of the substring). The number_characters is based on the number of characters, not bytes, so that multi-byte characters are counted as single characters. This number cannot be negative.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "binary_expression",
                    "description": "The binary_expression of data type VARBYTE to be searched.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "start_byte",
                    "description": "The position within the binary expression to begin the extraction, starting at 1. This number can be negative.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "number_bytes",
                    "description": "The number of bytes to extract, that is, the length of the substring. This number can't be negative.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SUBSTRING",
            "description": "Returns the subset of a string based on the specified start position. If the input is a character string, the start position and number of characters extracted are based on characters, not bytes, so that multi-byte characters are counted as single characters. If the input is a binary expression, the start position and extracted substring are based on bytes. You can't specify a negative length, but you can specify a negative starting position.",
            "syntax": "SUBSTRING(binary_expression,start_byte)",
            "arguments": [
                {
                    "name": "character_string",
                    "description": "The string to be searched. Non-character data types are treated like a string.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "start_position",
                    "description": "The position within the string to begin the extraction, starting at 1. The start_position is based on the number of characters, not bytes, so that multi-byte characters are counted as single characters. This number can be negative.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "number_characters",
                    "description": "The number of characters to extract (the length of the substring). The number_characters is based on the number of characters, not bytes, so that multi-byte characters are counted as single characters. This number cannot be negative.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "binary_expression",
                    "description": "The binary_expression of data type VARBYTE to be searched.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "start_byte",
                    "description": "The position within the binary expression to begin the extraction, starting at 1. This number can be negative.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "number_bytes",
                    "description": "The number of bytes to extract, that is, the length of the substring. This number can't be negative.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TRANSLATE",
            "description": "For a given expression, replaces all occurrences of specified characters with specified substitutes. Existing characters are mapped to replacement characters by their positions in thecharacters_to_replaceandcharacters_to_substitutearguments. If more characters are specified in thecharacters_to_replaceargument than in thecharacters_to_substituteargument, the extra characters from thecharacters_to_replaceargument are omitted in the return value. TRANSLATE is similar to theREPLACE functionand theREGEXP_REPLACE function, except that REPLACE substitutes one entire string with another string and REGEXP_REPLACE lets you search a string for a regular expression pattern, while TRANSLATE makes multiple single-character substitutions. If any argument is null, the return isNULL.",
            "syntax": "TRANSLATE(expression,characters_to_replace,characters_to_substitute)",
            "arguments": [
                {
                    "name": "expression",
                    "description": "The expression to be translated.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "characters_to_replace",
                    "description": "A string containing the characters to be replaced.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "characters_to_substitute",
                    "description": "A string containing the characters to substitute.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "TRIM",
            "description": "Trims a string by blanks or specified characters.",
            "syntax": "TRIM( [ BOTH | LEADING | TRAILING ] [trim_charsFROM ]string)",
            "arguments": [
                {
                    "name": "BOTH | LEADING | TRAILING",
                    "description": "(Optional) Specifies where to trim characters from. Use BOTH to remove leading and trailing characters, use LEADING to remove leading characters only, and use TRAILING to remove trailing characters only. If this parameter is omitted, both leading and trailing characters are trimmed.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "trim_chars",
                    "description": "(Optional) The characters to be trimmed from the string. If this parameter is omitted, blanks are trimmed.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "string",
                    "description": "The string to be trimmed.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "UPPER",
            "description": "Converts a string to uppercase. UPPER supports UTF-8 multibyte characters, up to a maximum of four bytes per character.",
            "syntax": "UPPER(string)",
            "arguments": [
                {
                    "name": "string",
                    "description": "The input parameter is a VARCHAR string or any other data type, such as CHAR , that can be implicitly converted to VARCHAR .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DECIMAL_PRECISION",
            "description": "Checks the precision of the maximum total number of decimal digits to be stored. This number includes both the left and right digits of the decimal point. The range of the precision is from 1 to 38, with a default of 38.",
            "syntax": "DECIMAL_PRECISION(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "DECIMAL_SCALE",
            "description": "Checks the number of decimal digits to be stored to the right of the decimal point. The range of the scale is from 0 to the precision point, with a default of 0.",
            "syntax": "DECIMAL_SCALE(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "IS_ARRAY",
            "description": "Checks whether a variable is an array. The function returnstrueif the variable is an array. The function also includes empty arrays. Otherwise, the function returnsfalsefor all other values, including null.",
            "syntax": "IS_ARRAY(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "IS_BIGINT",
            "description": "Checks whether a value is aBIGINT. The IS_BIGINT function returnstruefor numbers of scale 0 in the 64-bit range. Otherwise, the function returnsfalsefor all other values, including null and floating point numbers. The IS_BIGINT function is a superset of IS_INTEGER.",
            "syntax": "IS_BIGINT(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "IS_BOOLEAN",
            "description": "Checks whether a value is aBOOLEAN. The IS_BOOLEAN function returnstruefor constant JSON Booleans. The function returnsfalsefor any other values, including null.",
            "syntax": "IS_BOOLEAN(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "IS_CHAR",
            "description": "Checks whether a value is aCHAR. The IS_CHAR function returnstruefor strings that have only ASCII characters, because the CHAR type can store only characters that are in the ASCII format. The function returnsfalsefor any other values.",
            "syntax": "IS_CHAR(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "IS_DECIMAL",
            "description": "Checks whether a value is aDECIMAL. The IS_DECIMAL function returnstruefor numbers that are not floating points. The function returnsfalsefor any other values, including null. The IS_DECIMAL function is a superset of IS_BIGINT.",
            "syntax": "IS_DECIMAL(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "IS_FLOAT",
            "description": "Checks whether a value is a floating point number. The IS_FLOAT function returnstruefor floating point numbers (FLOAT4andFLOAT8). The function returnsfalsefor any other values. The set of IS_DECIMAL the set of IS_FLOAT are disjoint.",
            "syntax": "IS_FLOAT(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "IS_INTEGER",
            "description": "Returnstruefor numbers of scale 0 in the 32-bit range, andfalsefor anything else (including null and floating point numbers). The IS_INTEGER function is a superset of the IS_SMALLINT function.",
            "syntax": "IS_INTEGER(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "IS_OBJECT",
            "description": "Checks whether a variable is an object. The IS_OBJECT function returnstruefor objects, including empty objects. The function returnsfalsefor any other values, including null.",
            "syntax": "IS_OBJECT(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "IS_SCALAR",
            "description": "Checks whether a variable is a scalar. The IS_SCALAR function returnstruefor any value that is not an array or an object. The function returnsfalsefor any other values, including null. The set of IS_ARRAY, IS_OBJECT, and IS_SCALAR cover all values except nulls.",
            "syntax": "IS_SCALAR(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "IS_SMALLINT",
            "description": "Checks whether a variable is aSMALLINT. The IS_SMALLINT function returnstruefor numbers of scale 0 in the 16-bit range. The function returnsfalsefor any other values, including null and floating point numbers.",
            "syntax": "IS_SMALLINT(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "IS_VARCHAR",
            "description": "Checks whether a variable is aVARCHAR. The IS_VARCHAR function returnstruefor all strings. The function returnsfalsefor any other values. The IS_VARCHAR function is a superset of the IS_CHAR function.",
            "syntax": "IS_VARCHAR(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "JSON_SIZE",
            "description": "The JSON_SIZE function returns the number of bytes in the givenSUPERexpression when serialized into a string.",
            "syntax": "JSON_SIZE(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER constant or expression.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "JSON_TYPEOF",
            "description": "The JSON_TYPEOF scalar function returns aVARCHARwith values boolean, number, string, object, array, or null, depending on the dynamic type of theSUPERvalue.",
            "syntax": "JSON_TYPEOF(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER expression or column.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SIZE",
            "description": "Returns the binary in-memory size of aSUPERtype constant or expression as anINTEGER.",
            "syntax": "SIZE(super_expression)",
            "arguments": [
                {
                    "name": "super_expression",
                    "description": "A SUPER type constant or expression.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "CHANGE_QUERY_PRIORITY",
            "description": "CHANGE_QUERY_PRIORITY enables superusers to modify the priority of a query that is either running or waiting in workload management (WLM). This function enables superusers to immediately change the priority of any query in the system. Only one query, user, or session can run with the priorityCRITICAL.",
            "syntax": "CHANGE_QUERY_PRIORITY(query_id,priority)",
            "arguments": [
                {
                    "name": "query_id",
                    "description": "The query identifier of the query whose priority is changed. Requires an INTEGER value.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "priority",
                    "description": "The new priority to be assigned to the query. This argument must be a string with the value CRITICAL , HIGHEST , HIGH , NORMAL , LOW , or LOWEST .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "CHANGE_SESSION_PRIORITY",
            "description": "CHANGE_SESSION_PRIORITY enables superusers to immediately change the priority of any session in the system. Only one session, user, or query can run with the priorityCRITICAL.",
            "syntax": "CHANGE_SESSION_PRIORITY(pid,priority)",
            "arguments": [
                {
                    "name": "pid",
                    "description": "The process identifier of the session whose priority is changed. The value -1 refers to the current session. Requires an INTEGER value.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "priority",
                    "description": "The new priority to be assigned to the session. This argument must be a string with the value CRITICAL , HIGHEST , HIGH , NORMAL , LOW , or LOWEST .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "CHANGE_USER_PRIORITY",
            "description": "CHANGE_USER_PRIORITY enables superusers to modify the priority of all queries issued by a user that are either running or waiting in workload management (WLM). Only one user, session, or query can run with the priorityCRITICAL.",
            "syntax": "CHANGE_USER_PRIORITY(user_name,priority)",
            "arguments": [
                {
                    "name": "user_name",
                    "description": "The database user name whose query priority is changed.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "priority",
                    "description": "The new priority to be assigned to all queries issued by user_name . This argument must be a string with the value CRITICAL , HIGHEST , HIGH , NORMAL , LOW , LOWEST , or RESET . Only superusers can change the priority to CRITICAL . Changing the priority to RESET removes the priority setting for user_name .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "current_setting",
            "description": "CURRENT_SETTING returns the current value of the specified configuration parameter. This function is equivalent to theSHOWcommand.",
            "syntax": "current_setting('parameter')",
            "arguments": [
                {
                    "name": "parameter",
                    "description": "Parameter value to display. For a list of configuration parameters, see Configuration reference",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "variable_name",
                    "description": "The name of the variable to display. This must be a string constant for session context variables.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "error_if_undefined",
                    "description": "(Optional) A boolean value that specifies the behavior if the variable name doesn't exist. When error_if_undefined is set to TRUE , which is the default, Amazon Redshift throws an error. When error_if_undefined is set to FALSE , Amazon Redshift returns NULL . Amazon Redshift supports the error_if_undefined parameter only for session context variables. This can't be used when the input is a configuration parameter.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "current_setting",
            "description": "CURRENT_SETTING returns the current value of the specified configuration parameter. This function is equivalent to theSHOWcommand.",
            "syntax": "current_setting('variable_name')",
            "arguments": [
                {
                    "name": "parameter",
                    "description": "Parameter value to display. For a list of configuration parameters, see Configuration reference",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "variable_name",
                    "description": "The name of the variable to display. This must be a string constant for session context variables.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "error_if_undefined",
                    "description": "(Optional) A boolean value that specifies the behavior if the variable name doesn't exist. When error_if_undefined is set to TRUE , which is the default, Amazon Redshift throws an error. When error_if_undefined is set to FALSE , Amazon Redshift returns NULL . Amazon Redshift supports the error_if_undefined parameter only for session context variables. This can't be used when the input is a configuration parameter.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "current_setting",
            "description": "CURRENT_SETTING returns the current value of the specified configuration parameter. This function is equivalent to theSHOWcommand.",
            "syntax": "current_setting('variable_name'[,error_if_undefined])",
            "arguments": [
                {
                    "name": "parameter",
                    "description": "Parameter value to display. For a list of configuration parameters, see Configuration reference",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "variable_name",
                    "description": "The name of the variable to display. This must be a string constant for session context variables.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "error_if_undefined",
                    "description": "(Optional) A boolean value that specifies the behavior if the variable name doesn't exist. When error_if_undefined is set to TRUE , which is the default, Amazon Redshift throws an error. When error_if_undefined is set to FALSE , Amazon Redshift returns NULL . Amazon Redshift supports the error_if_undefined parameter only for session context variables. This can't be used when the input is a configuration parameter.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "pg_cancel_backend",
            "description": "Cancels a query. PG_CANCEL_BACKEND is functionally equivalent to theCANCELcommand. You can cancel queries currently being run by your user. Superusers can cancel any query.",
            "syntax": "pg_cancel_backend(pid)",
            "arguments": [
                {
                    "name": "pid",
                    "description": "The process ID (PID) of the query to be canceled. You cannot cancel a query by specifying a query ID; you must specify the query's process ID. Requires an INTEGER value.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "pg_terminate_backend",
            "description": "Terminates a session. You can terminate a session owned by your user. A superuser can terminate any session.",
            "syntax": "pg_terminate_backend(pid)",
            "arguments": [
                {
                    "name": "pid",
                    "description": "The process ID of the session to be terminated. Requires an INTEGER value.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "SELECTREBOOT_CLUSTER",
            "description": "Reboot the Amazon Redshift cluster without closing the connections to the cluster. You must be a database superuser to run this command. After this soft reboot has completed, the Amazon Redshift cluster returns an error to the user application and requires the user application to resubmit any transactions or queries interrupted by the soft reboot.",
            "syntax": "SELECTREBOOT_CLUSTER();",
            "arguments": null
        },
        {
            "name": "SET_CONFIG",
            "description": "Sets a configuration parameter to a new setting. This function is equivalent to the SET command in SQL.",
            "syntax": "SET_CONFIG('parameter', 'new_value' ,is_local)",
            "arguments": [
                {
                    "name": "parameter",
                    "description": "Parameter to set.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "variable_name",
                    "description": "The name of the variable to set.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "new_value",
                    "description": "New value of the parameter.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "is_local",
                    "description": "If true, parameter value applies only to the current transaction. Valid values are true or 1 and false or 0 .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "set_config",
            "description": "Sets a configuration parameter to a new setting. This function is equivalent to the SET command in SQL.",
            "syntax": "set_config('variable_name', 'new_value' ,is_local)",
            "arguments": [
                {
                    "name": "parameter",
                    "description": "Parameter to set.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "variable_name",
                    "description": "The name of the variable to set.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "new_value",
                    "description": "New value of the parameter.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "is_local",
                    "description": "If true, parameter value applies only to the current transaction. Valid values are true or 1 and false or 0 .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "c",
            "description": "Returns the AWS account associated with the Amazon Redshift cluster that submitted a query.",
            "syntax": "c(u",
            "arguments": null
        },
        {
            "name": "current_database",
            "description": "Returns the name of the database where you are currently connected.",
            "syntax": "current_database()",
            "arguments": null
        },
        {
            "name": "c",
            "description": "Returns the cluster namespace of the current Amazon Redshift cluster. Amazon Redshift cluster namespace is the unique ID of the Amazon Redshift cluster.",
            "syntax": "c(u",
            "arguments": null
        },
        {
            "name": "current_schema",
            "description": "Returns the name of the schema at the front of the search path. This schema will be used for any tables or other named objects that are created without specifying a target schema.",
            "syntax": "current_schema()",
            "arguments": null
        },
        {
            "name": "current_schemas",
            "description": "Returns an array of the names of any schemas in the current search path. The current search path is defined in the search_path parameter.",
            "syntax": "current_schemas(include_implicit)",
            "arguments": [
                {
                    "name": "include_implicit",
                    "description": "If true, specifies that the search path should include any implicitly included system schemas. Valid values are true and false . Typically, if true , this parameter returns the pg_catalog schema in addition to the current schema.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "c",
            "description": "Returns the user name of the current \"effective\" user of the database, as applicable to checking permissions. Usually, this user name will be the same as the session user; however, this can occasionally be changed by superusers. Do not use trailing parentheses when calling CURRENT_USER.",
            "syntax": "c(u",
            "arguments": null
        },
        {
            "name": "C",
            "description": "Returns the unique identifier for the Amazon Redshift user logged in to the current session.",
            "syntax": "C(U",
            "arguments": null
        },
        {
            "name": "selectdefault_iam_role",
            "description": "Returns the default IAM role currently associated with the Amazon Redshift cluster. The function returns none if there isn't any default IAM role associated.",
            "syntax": "selectdefault_iam_role();",
            "arguments": null
        },
        {
            "name": "has_assumerole_privilege",
            "description": "Returns Booleantrue(t) if the specified user has the specified IAM role with the privilege to run the specified command. The function returnsfalse(f) if the user doesn't have the specified IAM role with the privilege to run the specified command. For more information about privileges, seeGRANT.",
            "syntax": "has_assumerole_privilege( [user, ]iam_role_arn,cmd_type)",
            "arguments": [
                {
                    "name": "user",
                    "description": "The name of the user to check for IAM role privileges. The default is to check the current user. Superusers and users can use this function. However, users can only view their own privileges.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "iam_role_arn",
                    "description": "The IAM role that has been granted the command privileges.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "cmd_type",
                    "description": "The command for which access has been granted. Valid values are the following: COPY UNLOAD EXTERNAL FUNCTION CREATE MODEL",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "has_database_privilege",
            "description": "Returnstrueif the user has the specified privilege for the specified database. For more information about privileges, seeGRANT.",
            "syntax": "has_database_privilege( [user, ]database,privilege)",
            "arguments": [
                {
                    "name": "user",
                    "description": "The name of the user to check for database privileges. The default is to check the current user.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "database",
                    "description": "The database associated with the privilege.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "privilege",
                    "description": "The privilege to check. Valid values are the following: CREATE TEMPORARY TEMP",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "has_schema_privilege",
            "description": "Returnstrueif the user has the specified privilege for the specified schema. For more information about privileges, seeGRANT.",
            "syntax": "has_schema_privilege( [user, ]schema,privilege)",
            "arguments": [
                {
                    "name": "user",
                    "description": "The name of the user to check for schema privileges. The default is to check the current user.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "schema",
                    "description": "The schema associated with the privilege.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "privilege",
                    "description": "The privilege to check. Valid values are the following: CREATE USAGE",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "has_table_privilege",
            "description": "Returnstrueif the user has the specified privilege for the specified table and returnsfalseotherwise.",
            "syntax": "has_table_privilege( [user, ]table,privilege)",
            "arguments": [
                {
                    "name": "user",
                    "description": "The name of the user to check for table privileges. The default is to check the current user.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "table",
                    "description": "Table associated with the privilege.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "privilege",
                    "description": "Privilege to check. Valid values are the following: SELECT INSERT UPDATE DELETE DROP REFERENCES",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "last_user_query_id",
            "description": "Returns the query ID of the most recently completed user query in the current session. If no queries have been run in the current session, last_user_query_id returns -1. The function does not return the query ID for queries that run exclusively on the leader node. For more information, seeLeader node\u2013only functions.",
            "syntax": "last_user_query_id()",
            "arguments": null
        },
        {
            "name": "pg_backend_pid",
            "description": "Returns the process ID (PID) of the server process handling the current session. The PID is not globally unique. It can be reused over time.",
            "syntax": "pg_backend_pid()",
            "arguments": null
        },
        {
            "name": "pg_get_cols",
            "description": "Returns the column metadata for a table or view definition.",
            "syntax": "pg_get_cols('name')",
            "arguments": [
                {
                    "name": "name",
                    "description": "The name of an Amazon Redshift table or view. For more information, see Names and identifiers .",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "pg_get_grantee_by_iam_role",
            "description": "Returns all users and groups granted a specified IAM role.",
            "syntax": "pg_get_grantee_by_iam_role('iam_role_arn')",
            "arguments": [
                {
                    "name": "iam_role_arn",
                    "description": "The IAM role for which to return the users and groups that have been granted this role.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "pg_get_iam_role_by_user",
            "description": "Returns all IAM roles and command privileges granted to a user.",
            "syntax": "pg_get_iam_role_by_user('name')",
            "arguments": [
                {
                    "name": "name",
                    "description": "The name of the user for which to return IAM roles.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "pg_get_late_binding_view_cols",
            "description": "Returns the column metadata for all late-binding views in the database. For more information, seeLate-binding views",
            "syntax": "pg_get_late_binding_view_cols()",
            "arguments": null
        },
        {
            "name": "pg_last_copy_count",
            "description": "Returns the number of rows that were loaded by the last COPY command run in the current session. PG_LAST_COPY_COUNT is updated with the last COPY ID, which is the query ID of the last COPY that began the load process, even if the load failed. The query ID and COPY ID are updated when the COPY command begins the load process. If the COPY fails because of a syntax error or because of insufficient privileges, the COPY ID is not updated and PG_LAST_COPY_COUNT returns the count for the previous COPY. If no COPY commands were run in the current session, or if the last COPY failed during loading, PG_LAST_COPY_COUNT returns 0. For more information, seePG_LAST_COPY_ID.",
            "syntax": "pg_last_copy_count()",
            "arguments": null
        },
        {
            "name": "pg_last_copy_id",
            "description": "Returns the query ID of the most recently completed COPY command in the current session. If no COPY commands have been run in the current session, PG_LAST_COPY_ID returns -1. The value for PG_LAST_COPY_ID is updated when the COPY command begins the load process. If the COPY fails because of invalid load data, the COPY ID is updated, so you can use PG_LAST_COPY_ID when you query STL_LOAD_ERRORS table. If the COPY transaction is rolled back, the COPY ID is not updated. The COPY ID is not updated if the COPY command fails because of an error that occurs before the load process begins, such as a syntax error, access error, invalid credentials, or insufficient privileges. The COPY ID is not updated if the COPY fails during the analyze compression step, which begins after a successful connection, but before the data load.",
            "syntax": "pg_last_copy_id()",
            "arguments": null
        },
        {
            "name": "PG_LAST_UNLOAD_ID",
            "description": "Returns the query ID of the most recently completed UNLOAD command in the current session. If no UNLOAD commands have been run in the current session, PG_LAST_UNLOAD_ID returns -1. The value for PG_LAST_UNLOAD_ID is updated when the UNLOAD command begins the load process. If the UNLOAD fails because of invalid load data, the UNLOAD ID is updated, so you can use the UNLOAD ID for further investigation. If the UNLOAD transaction is rolled back, the UNLOAD ID is not updated. The UNLOAD ID is not updated if the UNLOAD command fails because of an error that occurs before the load process begins, such as a syntax error, access error, invalid credentials, or insufficient privileges.",
            "syntax": "PG_LAST_UNLOAD_ID()",
            "arguments": null
        },
        {
            "name": "pg_last_query_id",
            "description": "Returns the query ID of the most recently completed query in the current session. If no queries have been run in the current session, PG_LAST_QUERY_ID returns -1. PG_LAST_QUERY_ID does not return the query ID for queries that run exclusively on the leader node. For more information, seeLeader node\u2013only functions.",
            "syntax": "pg_last_query_id()",
            "arguments": null
        },
        {
            "name": "pg_last_unload_count",
            "description": "Returns the number of rows that were unloaded by the last UNLOAD command completed in the current session. PG_LAST_UNLOAD_COUNT is updated with the query ID of the last UNLOAD, even if the operation failed. The query ID is updated when the UNLOAD is completed. If the UNLOAD fails because of a syntax error or because of insufficient privileges, PG_LAST_UNLOAD_COUNT returns the count for the previous UNLOAD. If no UNLOAD commands were completed in the current session, or if the last UNLOAD failed during the unload operation, PG_LAST_UNLOAD_COUNT returns 0.",
            "syntax": "pg_last_unload_count()",
            "arguments": null
        },
        {
            "name": "SLICE_NUM",
            "description": "Returns an integer corresponding to the slice number in the cluster where the data for a row is located. SLICE_NUM takes no parameters.",
            "syntax": "SLICE_NUM()",
            "arguments": null
        },
        {
            "name": "role_is_member_of",
            "description": "Returns true if the role is a member of another role. Superusers can check the membership of all roles. Regular users who have the ACCESS SYSTEM TABLE permission can check all users' membership. Otherwise, regular users can only check roles to which they have access. Amazon Redshift errors out if the provided roles don't exist or the current user doesn't have access to the role.",
            "syntax": "role_is_member_of(role_name,granted_role_name)",
            "arguments": [
                {
                    "name": "role_name",
                    "description": "The name of the role.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "granted_role_name",
                    "description": "The name of the granted role.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "user_is_member_of",
            "description": "Returns true if the user is a member of a role or group. Superusers can check the membership of all users. Regular users who are members of the sys:secadmin or sys:superuser role can check all users' membership. Otherwise, regular users can only check themselves. Amazon Redshift sends an error if the provided identities don't exist or the current user doesn't have access to the role.",
            "syntax": "user_is_member_of(user_name,role_name|group_name)",
            "arguments": [
                {
                    "name": "user_name",
                    "description": "The name of the user.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "role_name",
                    "description": "The name of the role.",
                    "type": null,
                    "optional": null
                },
                {
                    "name": "group_name",
                    "description": "The name of the group.",
                    "type": null,
                    "optional": null
                }
            ]
        },
        {
            "name": "VERSION",
            "description": "The VERSION function returns details about the currently installed release, with specific Amazon Redshift version information at the end. This is a leader-node function. This function returns an error if it references a user-created table, an STL or STV system table, or an SVV or SVL system view.",
            "syntax": "VERSION()",
            "arguments": null
        }
    ]
}